<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icel&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-01T17:51:03.441Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Icel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于贝壳的一次爬虫经历</title>
    <link href="http://yoursite.com/2020/06/02/%E5%85%B3%E4%BA%8E%E8%B4%9D%E5%A3%B3%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2020/06/02/%E5%85%B3%E4%BA%8E%E8%B4%9D%E5%A3%B3%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/</id>
    <published>2020-06-01T16:39:16.000Z</published>
    <updated>2020-06-01T17:51:03.441Z</updated>
    
    <content type="html"><![CDATA[<p>这次爬虫过程相比较 p 站和 bing 来说，新加入了数据库部分，也遇到了一些新的问题，因此我认为有必要进行记录。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>爬取贝壳上所有城市的所有的项目信息，并保存到 mongoDB 中</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>分析 <a href="https://gz.fang.ke.com/loupan" target="_blank" rel="noopener">https://gz.fang.ke.com/loupan</a> 内数据的获取方式</li><li>尝试获取各城市贝壳网的链接地址</li><li>将数据保存到数据库(mongoDB)内</li></ol><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="分析链接"><a href="#分析链接" class="headerlink" title="分析链接"></a>分析链接</h3><p>由分析可知，贝壳网在获取全部楼盘列表时，会请求 <a href="https://gz.fang.ke.com/loupan/pg2/?_t=1" target="_blank" rel="noopener">https://gz.fang.ke.com/loupan/pg2/?_t=1</a> 这个网址，返回 json 数据。其中 pg2 指的是全部楼盘列表的当前显示页。因此只需要遍历所有的页就可以获得所有楼盘的基础数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errno"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"no_more_data"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"fb_query_id"</span>: <span class="string">"320001615984238592"</span>,</span><br><span class="line">    <span class="attr">"list"</span>: [↔],</span><br><span class="line">    <span class="attr">"switch_city"</span>: [↔],</span><br><span class="line">    <span class="attr">"total"</span>: <span class="string">"1095"</span>,</span><br><span class="line">    <span class="attr">"no_result_resblocks"</span>: [↔],</span><br><span class="line">    <span class="attr">"few_result_resblocks"</span>: [↔],</span><br><span class="line">    "selected": &#123;↔&#125;,</span><br><span class="line">    "hot_resblock": [↔]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个城市的楼盘数据是用 total 记录的。其中，每个楼盘的数据都保存在 list 中</p><details><summary>楼盘数据（例子）</summary><div style="white-space:pre;">{    "item_type": "0",    "item_type_desc": "",    "pid": "13607",    "id": "2113349626850729",    "city_id": "440100",    "city_name": "广州市",    "cover_pic": "https://ke-image.ljcdn.com/hdic-resblock/aee7be68-aad6-400c-bd4c-2093aee91a45.jpg",    "min_frame_area": "40",    "max_frame_area": "115",    "district_name": "增城",    "district": "增城",    "district_id": "23008643",    "bizcircle_id": "1100000717",    "bizcircle_name": "朱村",    "build_id": "2113349626850729",    "process_status": "3",    "resblock_frame_area": "建面 40-115㎡",    "resblock_frame_area_range": "40-115㎡",    "resblock_frame_area_desc": "建面",    "decoration": "精装修",    "longitude": "113.685415",    "latitude": "23.282883",    "frame_rooms_desc": "1/2/3居",    "title": "恒展江山时代花园",    "resblock_name": "恒展江山时代花园",    "resblock_alias": "江山时代花园",    "address": "朱村大道西88号",    "store_addr": "朱村大道西88号",    "avg_unit_price": "25000",    "average_price": "21000",    "address_remark": "朱村大道西88号",    "project_name": "hzjssdhyaaudj",    "special_tags": [],    "special": {        "lianjia_special": [],        "lianjia_special_comm": "",        "developer_special": [],        "developer_special_comm": ""    },    "frame_rooms": [],    "converged_rooms": [        {            "bedroom_count": "2",            "area_range": "76㎡"        },        {            "bedroom_count": "3",            "area_range": "85-114㎡"        }    ],    "tags": ["小户型", "入户花园", "地铁沿线", "近主干道"],    "project_tags": [        {            "id": "14",            "desc": "小户型",            "color": ""        },        {            "id": "32",            "desc": "入户花园",            "color": ""        },        {            "id": "1",            "desc": "地铁沿线",            "color": ""        },        {            "id": "43",            "desc": "近主干道",            "color": ""        }    ],    "house_type": "住宅",    "house_type_value": "107500000003",    "sale_status": "在售",    "has_evaluate": "0",    "has_vr_aerial": "0",    "has_vr_house": "1",    "has_short_video": "0",    "open_date": "2018-07-07",    "has_virtual_view": "1",    "lowest_total_price": "1600000",    "show_price": "21000",    "show_price_unit": "元/平",    "show_price_desc": "均价",    "show_price_confirm_time": "53天",    "price_confirm_time": "2020-04-09 19:52:36",    "status": "2",    "subway_distance": "距21号线凤岗站0米",    "is_cooperation": "2",    "evaluate_status": "0",    "show_price_info": "均价21000元/平",    "brand_id": "101",    "preload_detail_image": [        {            "id": "img_3476209",            "image_id": "3476209",            "type_id": "101900000004",            "type_name": "效果图",            "image_url": "https://ke-image.ljcdn.com/hdic-resblock/aee7be68-aad6-400c-bd4c-2093aee91a45.jpg",            "title": "",            "desc": "",            "extend": null,            "vr_info": null,            "video_info": null,            "image_list_blurry_url": "https://image1.ljcdn.com/hdic-resblock/aee7be68-aad6-400c-bd4c-2093aee91a45.jpg!m_fill,w_60,l_fbk,q_90",            "image_size_url": "https://image1.ljcdn.com/hdic-resblock/aee7be68-aad6-400c-bd4c-2093aee91a45.jpg!m_fill,w_750,h_562,l_fbk",            "image_list_size_url": "https://image1.ljcdn.com/hdic-resblock/aee7be68-aad6-400c-bd4c-2093aee91a45.jpg!m_fill,w_1440,l_fbk"        }    ],    "reference_avg_price": "21000",    "reference_avg_price_unit": "元/㎡",    "reference_avg_price_desc": "参考均价",    "reference_total_price": "0",    "reference_total_price_unit": "万/套",    "reference_total_price_desc": "总价",    "new_sale_tags": [],    "is_followed": "0",    "is_support_online_sale": "0",    "is_undertake": "0",    "properright": "",    "developer_company": ["广州恒展房地产开发有限公司"],    "property_company": [],    "live_tag": "0",    "prod": "1",    "sale_status_color": "5F94FF",    "house_type_color": "FB9252",    "total_price_start": "150",    "total_price_start_unit": "万/套",    "avg_price_start": "18859",    "avg_price_start_unit": "元/平",    "on_time": "2018-12-24 10:07:46",    "project_desc": "邻铁900米，刚需小户型",    "has_car_activity": "1",    "is_new_sale": "0",    "first_tags": [        {            "desc": "VR售楼部",            "color": "F66B65",            "text_color": "FFFFFF"        },        {            "desc": "免费专车",            "color": "FF984C",            "text_color": "FFFFFF"        }    ],    "m_first_tags": [        {            "desc": "免费专车",            "color": "FF984C",            "text_color": "FFFFFF"        }    ],    "fb_expo_id": "320001616001015809",    "strategy_info": "{\"fb_query_id\":\"320001615984238592\",\"fb_expo_id\":\"320001616001015809\",\"fb_item_location\":\"1\",\"fb_service_id\":\"1012810001\",\"fb_ab_test_flag\":\"[\\\"ab-group: [    ab-test-exp-476-group-1,    ab-test-exp-477-group-3,    ab-test-exp-480-group-2,    ab-test-exp-481-group-4,    ab-test-exp-482-group-4,    ab-test-exp-484-group-5    ]\\\"]\",\"fb_item_id\":\"13607\"}",    "recommend_log_info": "",    "recommend_reason": {        "type": "4",        "name": "楼盘亮点",        "details": "邻铁900米，刚需小户型"    },    "url": "/loupan/p_hzjssdhyaaudj/"}</div></details><p>因此，一座城市全部的楼盘情况就都可以拿下来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取总页数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_total_project_num</span><span class="params">(self, city_url)</span>:</span></span><br><span class="line">    req = requests.get(<span class="string">f'<span class="subst">&#123;city_url&#125;</span>/pg1/?_t=1'</span>)</span><br><span class="line">    <span class="keyword">return</span> req.json()[<span class="string">'data'</span>][<span class="string">'total'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程下载每一页的项目信息(同时下载，并没有间隔一定时间)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_project_data</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                    city_url,</span></span></span><br><span class="line"><span class="function"><span class="params">                    city_collection,</span></span></span><br><span class="line"><span class="function"><span class="params">                    start_page=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    end_page=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> end_page:</span><br><span class="line">        end_page = ceil(int(self.get_total_project_num(city_url)) / <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        self.get_data_from_page(city_url, page, city_collection)</span><br><span class="line">        print(<span class="string">f'下载了第<span class="subst">&#123;page&#125;</span>页的数据'</span>)</span><br><span class="line">        <span class="comment"># 这里原本想用异步的，因为贝壳限制同一ip短时间内的请求次数。如果次数过多会直接跳入验证人机页面。因此改用延时处理</span></span><br><span class="line">        sleep(randint(<span class="number">300</span>, <span class="number">700</span>) / <span class="number">100</span>)</span><br><span class="line">        <span class="comment"># Thread(target=self.get_data_from_page, args=(city_url, page, city_collection)).start()</span></span><br><span class="line">    print(<span class="string">'全部下载完了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理每一页拿到的项目信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_from_page</span><span class="params">(self, city_url, page, city_collection)</span>:</span></span><br><span class="line">    req = requests.get(<span class="string">f'<span class="subst">&#123;city_url&#125;</span>/pg<span class="subst">&#123;str(page)&#125;</span>/?_t=1'</span>)</span><br><span class="line">    project_list = req.json()[<span class="string">'data'</span>][<span class="string">'list'</span>]</span><br></pre></td></tr></table></figure><h3 id="获取城市链接地址"><a href="#获取城市链接地址" class="headerlink" title="获取城市链接地址"></a>获取城市链接地址</h3><p>因为贝壳单页面上存在选择城市的链接组，因此直接请求指定网站，并用正则表达式直接获取所有城市的链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制作一个城市链接地址的迭代器，需要用try-except和StopIteration来防止输出结束后的报错</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_city_url</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">'https://hz.fang.ke.com/loupan'</span></span><br><span class="line">    req = requests.get(url)</span><br><span class="line">    city_url_regexp = re.compile(</span><br><span class="line">        <span class="string">'(?!&lt;a href=")\/\/.&#123;1,15&#125;\.fang\.ke\.com\/loupan'</span>)</span><br><span class="line">    city_url_array = list(set(re.findall(city_url_regexp, req.text)))</span><br><span class="line">    city_url_length = len(city_url_array)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; city_url_length:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'https:'</span> + city_url_array[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>因为 json 数据中存在数组，因此直接选用 MongoDB 这样依赖 json 格式储存数据的数据库。每个 collection 的名字用连接里城市的缩写来命名。另外我将需要请求的数据直接做成数据的样子，比较好管理，不过我觉得应该直接保存成 json 文件，而不是做成 return 的样子会更好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># get_project_kws文件的keywords函数就是返回一个json文件，里面保存着文件名和对应的贝壳json中的名字</span></span><br><span class="line"><span class="keyword">from</span> keywords <span class="keyword">import</span> get_project_kws</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mongodb</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        client = MongoClient(<span class="string">'mongodb://127.0.0.1:27017'</span>)</span><br><span class="line">        self.db = client.beike</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成指定城市名的collection</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_col</span><span class="params">(self, city_url)</span>:</span></span><br><span class="line">        city_short = re.split(<span class="string">'\.'</span>, city_url[<span class="number">8</span>:])[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> city_short <span class="keyword">in</span> self.db.list_collection_names():</span><br><span class="line">            <span class="keyword">return</span> self.db.get_collection(city_short)</span><br><span class="line">            <span class="comment"># self.db.drop_collection(city_short)</span></span><br><span class="line">        city = self.db.create_collection(city_short)</span><br><span class="line">        <span class="keyword">return</span> city</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入数据 -- project_list指的是解析网站回馈的json后拿到的项目列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_data</span><span class="params">(self, collection, project_list)</span>:</span></span><br><span class="line">        kw_array = get_project_kws()[<span class="string">'keywords'</span>]</span><br><span class="line">        <span class="keyword">for</span> project <span class="keyword">in</span> project_list:</span><br><span class="line">            obj = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> kw <span class="keyword">in</span> kw_array:</span><br><span class="line">                obj[kw[<span class="string">'kw'</span>]] = project[kw[<span class="string">'data_kw'</span>]]</span><br><span class="line">            collection.insert_one(obj)</span><br></pre></td></tr></table></figure><p>最终将各部分拼接起来就可以了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>实际上本次的爬虫存在很多问题</p><ol><li><p>爬取数据很慢。虽然 sleep 设置了 0.3 秒到 0.7 秒，但每一页数据都花费了大概 1 秒左右的时间，说明程序的效率并不是很高，只是满足了功能而已</p></li><li><p>本次爬虫使我深刻认识到动态 ip 的重要性。如果能够多线程同步进行爬取，速率可以大大提升</p></li><li><p>本次爬虫还有一个比较致命的点。贝壳里所有城市链接里所有数据全爬下来，意味着数据量很大。如果中途出现网络连接故障，或者我想要中途停止，后期再继续爬的话，在本程序中完全没有设计这样的保护机制，会让前面爬取的数据都付诸东流。本次爬虫从晚上开始，一直爬到第二天早上，甚至上班路上还在爬，快到单位才爬完 TAT。因此，保护机制很重要。如果依靠 scrapy 去爬取的话，scrapy 内部有保护机制，就可以有效避免这样的情况。</p></li><li><p>虽然一个城市的所有楼盘都能获取到，但实际上请求 json 所返回的数据与实际网站上给出的数据的顺序是不一致的，这说明贝壳网在显示数据前，很可能预先获得用户所在地址后再定向推荐的。而这个也是本次程序所没有考虑到的点。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次爬虫过程相比较 p 站和 bing 来说，新加入了数据库部分，也遇到了一些新的问题，因此我认为有必要进行记录。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;爬取贝壳上
      
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python的time模块</title>
    <link href="http://yoursite.com/2020/06/01/python%E7%9A%84time%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/06/01/python%E7%9A%84time%E6%A8%A1%E5%9D%97/</id>
    <published>2020-06-01T15:57:10.000Z</published>
    <updated>2020-06-01T16:30:42.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="time-模块－－时间获取和转换"><a href="#time-模块－－时间获取和转换" class="headerlink" title="time 模块－－时间获取和转换"></a>time 模块－－时间获取和转换</h1><blockquote><p>time 模块提供各种时间相关的功能</p></blockquote><p>与时间相关的模块有：time,datetime,calendar</p><h2 id="必要说明："><a href="#必要说明：" class="headerlink" title="必要说明："></a>必要说明：</h2><p>这个模块的功能不是适用于所有的平台</p><p>这个模块中定义的大部分函数是调用 C 平台上的同名函数实现</p><p>一些术语和约定的解释：</p><ol><li><p>时间戳(timestamp)的方式：通常来说，时间戳表示的是从 1970 年 1 月１日开始按秒计算的偏移量(time.gmtime(0))此模块中的函数无法处理 1970 纪元年以前的时间或太遥远的未来(处理极限取决于 C 函数库，对于 32 位系统而言，是 2038 年)</p></li><li><p>UTC(Coordinated Universal Time,世界协调时)也叫格林威治天文时间，是世界标准时间．在我国为 UTC+8</p></li><li><p>DST(Daylight Saving Time)即夏令时</p></li><li><p>一些实时函数的计算精度可能不同</p></li></ol><h2 id="时间元祖-time-struct-time"><a href="#时间元祖-time-struct-time" class="headerlink" title="时间元祖(time.struct_time)"></a>时间元祖(time.struct_time)</h2><p>gmtime(),localtime()和 strptime()以时间元祖(struct_time)的形式返回</p><table><tr><th>索引值(index)</th> <th>属性(Attribute)</th> <th>值(Values)</th> </tr><tr><td>0</td><td>tm_year(年)</td><td>(例如:2015)</td></tr><tr><td>1</td><td>tm_mon(月)</td><td>1-12</td></tr><tr><td>2</td><td>tm_mday(日)</td><td>1-31</td></tr><tr><td>3</td><td>tm_hour(时)</td><td>0-23</td></tr><tr><td>4</td><td>tm_min(分)</td><td>0-59</td></tr><tr><td>5</td><td>tm_sec(秒)</td><td>0-61(60 代表闰秒,61 是基于历史原因保留)</td></tr><tr><td>6</td><td>tm_wday(星期几)</td><td>0-6(0表示星期一)</td></tr><tr><td>7</td><td>tm_yday(一年中的第几天)</td><td>1-366</td></tr><tr><td>8</td><td>tm_isdst(是否为夏令时)</td><td>0,1,-1(-1 代表夏令时)</td></tr></table><h2 id="time-altzone"><a href="#time-altzone" class="headerlink" title="time.altzone"></a>time.altzone</h2><p>返回格林威治西部的夏令时地区的偏移秒数，如果该地区在格林威治东部会返回负值(如西欧，包括英国)，对夏令时启用地区才能使用</p><h2 id="time-asctime-t"><a href="#time-asctime-t" class="headerlink" title="time.asctime([t])"></a>time.asctime([t])</h2><p>接受时间元组并返回一个可读的形式”Tue May 30 17:17:30 2017”(2017 年 5 月 30 日周二 17 时 17 分 30 秒)的 24 个字符的字符串</p><h2 id="time-clock"><a href="#time-clock" class="headerlink" title="time.clock()"></a>time.clock()</h2><p>用以浮点数计算的秒数返回当前的 CPU 时间，用来衡量不同程序的耗时，比 time.time()更有用<br>python3.3 以后不被推荐使用，该方法依赖操作系统，建议使用 per_counter(返回系统运行时间)或 process_time(返回进程运行时间)代替</p><h2 id="time-ctime-secs"><a href="#time-ctime-secs" class="headerlink" title="time.ctime([secs])"></a>time.ctime([secs])</h2><p>作用相当于 asctime(localtime(secs)),未给参数相当于 asctime()</p><h2 id="time-gmtime-secs"><a href="#time-gmtime-secs" class="headerlink" title="time.gmtime([secs])"></a>time.gmtime([secs])</h2><p>接收时间辍(1970 纪元年后经过的浮点秒数)并返回格林威治天文时间下的时间元组 t(t.tm_isdst 始终为０)</p><h2 id="time-daylight"><a href="#time-daylight" class="headerlink" title="time.daylight"></a>time.daylight</h2><p>如果夏令时被定义，则该值为非零</p><h2 id="time-localtime-secs"><a href="#time-localtime-secs" class="headerlink" title="time.localtime([secs])"></a>time.localtime([secs])</h2><p>接收时间辍(1970 纪元年后经过的浮点秒数)并返回当地时间下的时间元组 t(t.tm_isdst 可取为０或１，取决于当地当时是不是夏令时)</p><h2 id="time-mktime-t"><a href="#time-mktime-t" class="headerlink" title="time.mktime(t)"></a>time.mktime(t)</h2><p>接受时间元组并返回时间辍(1970 纪元年后经过的浮点秒数)</p><h2 id="time-perf-counter"><a href="#time-perf-counter" class="headerlink" title="time.perf_counter()"></a>time.perf_counter()</h2><p>返回计时器的精准时间(系统的运行时间)，包含整个系统的睡眠时间．由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的</p><h2 id="time-process-time"><a href="#time-process-time" class="headerlink" title="time.process_time()"></a>time.process_time()</h2><p>返回当前进程执行 CPU 的时间总和，不包含睡眠时间．由于返回值的基准点是未定义的，所以只有连续调用的结果之间的差才是有效的</p><h2 id="time-sleep-secs"><a href="#time-sleep-secs" class="headerlink" title="time.sleep(secs)"></a>time.sleep(secs)</h2><p>推迟调用线程的运行，secs 的单位是秒</p><h2 id="time-strftime-format-t"><a href="#time-strftime-format-t" class="headerlink" title="time.strftime(format[,t])"></a>time.strftime(format[,t])</h2><p>把一个代表时间的元组或者 struct_time(如由 time.localtime()和 time.gmtime()返回)转化为格式化的时间字符串．如果 t 未指定，将传入 time.localtime()，如果元组中任命一个元素越界，将会抛出 ValueError 异常</p><details><summary>format 格式如下：</summary><p>%a 本地(local)简化星期名称</p><p>%A 本地完整星期名称</p><p>%b 本地简化月份名称</p><p>%B 本地完整月份名称</p><p>%c 本地相应的日期和时间表示</p><p>%d 一个月中的第几天(01-31)</p><p>%H 一天中的第几个小时(24 小时制，00-23)</p><p>%l 一天中的第几个小时(12 小时制，01-12)</p><p>%j 一年中的第几天(01-366)</p><p>%m 月份(01-12)</p><p>%M 分钟数(00-59)</p><p>%p 本地 am 或者 pm 的相应符</p><p>%S 秒(01-61)</p><p>%U 一年中的星期数(00-53,星期天是一个星期的开始,第一个星期天之前的所有天数都放在第０周)</p><p>%w 一个星期中的第几天(0-6,0 是星期天)</p><p>%W 和%U 基本相同，不同的是%W 以星期一为一个星期的开始</p><p>%x 本地相应日期</p><p>%X 本地相应时间</p><p>%y 去掉世纪的年份(00-99)</p><p>%Y 完整的年份</p><p>%z 用+HHMM 或者-HHMM 表示距离格林威治的时区偏移(H 代表十进制的小时数，M 代表十进制的分钟数)</p><p>%Z 时区的名字(如果不存在为空字符)</p><p>%% %号本身</p><p>%p 只有与%I 配合使用才有效果</p><p>当使用 strptime()函数时，只有当在这年中的周数和天数被确定的时候%U 和%W 才会被计算</p></details><h2 id="time-strptime-string-format"><a href="#time-strptime-string-format" class="headerlink" title="time.strptime(string[,format])"></a>time.strptime(string[,format])</h2><p>把一个格式化时间字符串转化为 struct_time,实际上它和 strftie()是逆操作</p><h2 id="time-time"><a href="#time-time" class="headerlink" title="time.time()"></a>time.time()</h2><p>返回当前时间的时间戳(1970 元年后的浮点秒数)</p><h2 id="time-timezone"><a href="#time-timezone" class="headerlink" title="time.timezone()"></a>time.timezone()</h2><p>是当地时区(未启动夏令时)距离格林威治的偏移秒数(美洲＞０，欧洲大部分，亚洲，非洲&lt;＝０)</p><h2 id="time-tzname"><a href="#time-tzname" class="headerlink" title="time.tzname"></a>time.tzname</h2><p>包含两个字符串的元组，第一是当地夏令时区的名称，第二是当地的 DST 时区的名称<br>下面是一些经常会用到的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Time: 2019/9/18 11:14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Author:renpingsheng</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> **future** <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cutten_timestr</span><span class="params">(flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">获取当前时间字符串</span></span><br><span class="line"><span class="string">@return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line"><span class="keyword">return</span> datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="keyword">return</span> datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_timestr_to_timestamp</span><span class="params">(time_str, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把时间字符串转换为时间戳格式</span></span><br><span class="line"><span class="string">:param time_str: 时间字符串,格式为：2019-01-01 12:12:12 或 2019-01-01</span></span><br><span class="line"><span class="string">:param flag: 标志位，决定输入时间字符串的格式</span></span><br><span class="line"><span class="string">:return: 时间戳格式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">struct_time = time.strptime(time_str, <span class="string">"%Y-%m-%d %H:%M:%S"</span>) <span class="comment"># 2019-01-01 12:12:12</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">struct_time = time.strptime(time_str, <span class="string">"%Y-%m-%d"</span>) <span class="comment"># 2019-01-01</span></span><br><span class="line"><span class="keyword">return</span> time.mktime(struct_time)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_month_to_timestamp</span><span class="params">(month_str, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把月份字符串转化为时间戳</span></span><br><span class="line"><span class="string">:param month_str: 月份，例如：2019-01 或者 2019.01</span></span><br><span class="line"><span class="string">:param flag: 标志位，控制输入月份字符串的格式</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">struct_time = time.strptime(month_str, <span class="string">"%Y-%m"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">struct_time = time.strptime(month_str, <span class="string">"%Y.%m"</span>)</span><br><span class="line"><span class="keyword">return</span> time.mktime(struct_time)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_timestamp_to_timestr</span><span class="params">(time_stamp, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把时间戳转换为时间字符串</span></span><br><span class="line"><span class="string">:param time_stamp: 时间戳</span></span><br><span class="line"><span class="string">:param flag: 标志位，可以指定输出时间字符串的格式</span></span><br><span class="line"><span class="string">:return: 时间字符串,格式为：2019-01-01 12:12:12 或 2019-01-01</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">localtime = time.localtime(time_stamp)</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">time_str = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, localtime)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">time_str = time.strftime(<span class="string">"%Y-%m-%d"</span>, localtime)</span><br><span class="line"><span class="keyword">return</span> time_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_day_list</span><span class="params">(start_timestamp, end_timestamp, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">传入开始时间戳和结束时间戳，获取时间段内的日期列表</span></span><br><span class="line"><span class="string">:param start_timestamp: 开始时间戳</span></span><br><span class="line"><span class="string">:param end_timestamp: 结束时间戳</span></span><br><span class="line"><span class="string">:param flag: 标志位</span></span><br><span class="line"><span class="string">:return: 日期列表</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">tmp = range(int(start_timestamp), int(end_timestamp), <span class="number">3600</span> \* <span class="number">24</span>)</span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">tmp_range = [&#123;<span class="string">"day_str"</span>: parse_timestamp_to_timestr(i, flag=<span class="literal">False</span>)&#125; <span class="keyword">for</span> i <span class="keyword">in</span> tmp]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp_range = [parse_timestamp_to_timestr(i, flag=<span class="literal">False</span>) <span class="keyword">for</span> i <span class="keyword">in</span> tmp]</span><br><span class="line"><span class="keyword">return</span> tmp_range</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">day</span>*<span class="title">range</span><span class="params">(interval_day)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">获取指定天内的时间字符串的列表</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">c_time = (int(time.time() / (<span class="number">24</span> * <span class="number">3600</span>)) + <span class="number">1</span>) _ <span class="number">24</span> _ <span class="number">3600</span></span><br><span class="line">day*range_str = c_time - <span class="number">24</span> * <span class="number">3600</span> \* interval_day</span><br><span class="line"></span><br><span class="line">    day_list = [&#123;<span class="string">"day_str"</span>: parse_timestamp_to_timestr(t, flag=<span class="literal">False</span>)&#125; <span class="keyword">for</span> t <span class="keyword">in</span> range(day_range_str, c_time, <span class="number">3600</span> * <span class="number">24</span>)]</span><br><span class="line">    <span class="keyword">return</span> day_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">covert</span>*<span class="title">time</span><span class="params">(time_str)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把时间段转换为秒数</span></span><br><span class="line"><span class="string">:param time_str:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> time_str.endswith(<span class="string">"h"</span>):</span><br><span class="line">stamp = float(time_str.strip(<span class="string">"h"</span>)) * <span class="number">3600</span></span><br><span class="line"><span class="keyword">elif</span> time*str.endswith(<span class="string">"m"</span>):</span><br><span class="line">stamp = float(time_str.strip(<span class="string">"m"</span>)) * <span class="number">60</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stamp = float(time_str)</span><br><span class="line"><span class="keyword">return</span> stamp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_timestr_to_datetime</span><span class="params">(timestr, flag=<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把时间字符串转化为 datetime</span></span><br><span class="line"><span class="string">:param timestr: 时间字符串，例如：2019-01-01 12:12:12 或者 2019.01.01 12:12:12</span></span><br><span class="line"><span class="string">:param flag: 标志位，控制输入时间字符串的格式</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">tmp_datetime = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">2</span>:</span><br><span class="line">tmp_datetime = datetime.datetime.strptime(timestr, <span class="string">"%Y.%m.%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">3</span>:</span><br><span class="line">tmp_datetime = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line"><span class="keyword">elif</span> flag == <span class="number">4</span>:</span><br><span class="line">tmp_datetime = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp_datetime = datetime.datetime.strptime(timestr, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">return</span> tmp_datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_format_timestr</span><span class="params">(format_timestr)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">将格式字符串转换为时间戳</span></span><br><span class="line"><span class="string">:param format_timestr: 格式字符串,格式： "Sat Mar 28 22:24:24 2016"</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">tmp_timestamp = time.mktime(time.strptime(format_timestr, <span class="string">"%a %b %d %H:%M:%S %Y"</span>))</span><br><span class="line"><span class="keyword">return</span> tmp_timestamp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_datetime_to_string</span><span class="params">(datetime_str, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把 datetime 时间转化成时间字符串</span></span><br><span class="line"><span class="string">:param datetime_str: datetime 生成的时间，例子：datetime.datetime.now()</span></span><br><span class="line"><span class="string">或者： datetime.datetime.now() - datetime.timedelta(hours=1) # 一个小时之前</span></span><br><span class="line"><span class="string">或者： datetime.datetime.now() - datetime.timedelta(days=1) # 一天之前</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span> <span class="comment"># 将日期转化为字符串 datetime =&gt; string # 在数据库中定义字段信息时为：models.DateTimeField(auto_now_add=True) # 查询数据库之后，使用此方法把查询到的时间转换成可用的时间字符串 # when_insert\_\_range=(an_hour_time, now_time) # an_hour_time 和 now_time 都是 datetime 时间字符串，查询两个 datetime 时间字符串之间的数据</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line"><span class="keyword">return</span> datetime_str.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> datetime_str.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_datetime_to_timestamp</span><span class="params">(datetime_str)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把 datetime 转化成时间戳</span></span><br><span class="line"><span class="string">@param datetime_str: datetime 时间，比如：datetime.datetime.now()</span></span><br><span class="line"><span class="string">@return: 时间戳，比如：1565663994.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">return</span> time.mktime(datetime_str.timetuple())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_timestamp_to_datetime</span><span class="params">(timestamp, flag=True)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">把时间戳转化为 datetime 时间</span></span><br><span class="line"><span class="string">@param timestamp: 时间戳，比如：1553361411</span></span><br><span class="line"><span class="string">@param flag: 标志位，决定转化成 datetime 的时间</span></span><br><span class="line"><span class="string">@return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line"><span class="keyword">return</span> datetime.datetime.fromtimestamp(timestamp) <span class="comment"># 东八区的 datetime 时间</span></span><br><span class="line"><span class="keyword">return</span> datetime.datetime.utcfromtimestamp(timestamp) <span class="comment"># 正常的 UTC 时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_dur_time</span><span class="params">(d1, d2)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">获取两个 datetime 时间 间隔的日期数(天数，小时数和秒数)</span></span><br><span class="line"><span class="string">:param d1: 开始时间</span></span><br><span class="line"><span class="string">:param d2: 结束时间</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">dur_str = <span class="string">""</span></span><br><span class="line">dur_day = (d2 - d1).days</span><br><span class="line">dur_second = (d2 - d1).seconds</span><br><span class="line"><span class="keyword">if</span> dur_day &gt; <span class="number">0</span>:</span><br><span class="line">dur_str += <span class="string">"%s 天"</span> % str(dur_day)</span><br><span class="line"><span class="keyword">if</span> dur_second - <span class="number">3600</span> &gt; <span class="number">0</span>:</span><br><span class="line">dur_hour = dur_second // <span class="number">3600</span></span><br><span class="line">dur_str += <span class="string">"%s 小时"</span> % str(dur_hour)</span><br><span class="line"><span class="keyword">if</span> (dur_second % <span class="number">3600</span>) &gt; <span class="number">60</span>:</span><br><span class="line">dur_minute = (dur_second % <span class="number">3600</span>) // <span class="number">60</span></span><br><span class="line">dur_str += <span class="string">"%s 分钟"</span> % str(dur_minute)</span><br><span class="line">dur_str += <span class="string">"%s 秒"</span> % str(dur_second % <span class="number">60</span>)</span><br><span class="line"><span class="keyword">return</span> dur_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_month_start</span><span class="params">(datetime_str)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">datetime_str 可以是：datetime.date.today() ,也可以是：datetime.datetime.now()</span></span><br><span class="line"><span class="string">传入 datetime 时间，获取 datetime 时间当月第一天</span></span><br><span class="line"><span class="string">返回传入的 datetime 时间的第一天的时间字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">month_start = datetime.datetime(datetime_str.year, datetime_str.month, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> month_start.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_month_end</span><span class="params">(datetime_str)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">datetime_str 可以是：datetime.date.today() ,也可以是：datetime.datetime.now()</span></span><br><span class="line"><span class="string">传入 datetime 时间，获取 datetime 时间当月最后一天</span></span><br><span class="line"><span class="string">返回传入的 datetime 时间的最后一天的时间字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">if</span> data_date.month == <span class="number">12</span>:</span><br><span class="line">month_end = datetime.datetime(datetime_str.year, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">month_end = datetime.datetime(datetime_str.year, datetime_str.month + <span class="number">1</span>, <span class="number">1</span>) - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> month_end.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;time-模块－－时间获取和转换&quot;&gt;&lt;a href=&quot;#time-模块－－时间获取和转换&quot; class=&quot;headerlink&quot; title=&quot;time 模块－－时间获取和转换&quot;&gt;&lt;/a&gt;time 模块－－时间获取和转换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;t
      
    
    </summary>
    
    
      <category term="模块" scheme="http://yoursite.com/categories/%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="模块" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>关于pixiv的一次爬虫经历</title>
    <link href="http://yoursite.com/2020/05/19/%E5%85%B3%E4%BA%8Epixiv%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2020/05/19/%E5%85%B3%E4%BA%8Epixiv%E7%9A%84%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%8F%E5%8E%86/</id>
    <published>2020-05-19T15:58:36.000Z</published>
    <updated>2020-05-20T14:34:59.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天对 pixiv 插画网站进行了爬虫尝试，下面是对这次爬虫的记录</p></blockquote><h4 id="网站情况"><a href="#网站情况" class="headerlink" title="网站情况"></a>网站情况</h4><ol><li>基础网址为: <a href="https://www.pixiv.com" target="_blank" rel="noopener">https://www.pixiv.com</a></li><li>对于图片的请求，需要添加请求头 <code>referer:https://www.pixiv.net/artworks/图片号码</code> 例 <code>headers = {&#39;referer&#39;: &#39;https://www.pixiv.net/artworks/81618055&#39;}</code></li><li>如果有查看更多，需要请求 <code>https://www.pixiv.net/ajax/illust/图片号码/pages?lang=zh</code> 拿到里面包含的图片地址</li><li>如果需要下多天的排行榜图片，需要请求 <code>https://www.pixiv.net/ranking.php?mode=daily&amp;date=20200517</code></li><li>可以搜索每天排名前 500 的图片，需要修改参数 p 的值，范围 1 到 10 <code>https://www.pixiv.net/ranking.php?mode=daily&amp;p=10&amp;format=json</code></li><li>搜索图片可以用 <code>https://www.pixiv.net/ajax/search/artworks/%E3%82%BF%E3%82%A4%E3%83%84?word=%E3%82%BF%E3%82%A4%E3%83%84&amp;order=date_d&amp;mode=all&amp;p=1&amp;s_mode=s_tag&amp;type=all&amp;lang=zh</code>这个链接</li><li>搜索图片的话，一次请求 60 条</li></ol><p>以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只用来下载一张图片，这样可以实现并行操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadImg</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img_link)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._img_link = img_link</span><br><span class="line">        self._image_addr = <span class="string">'C:/Users/Administrator/Desktop/jiepai/pixiv/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按列表下载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        img_date = re.findall(</span><br><span class="line">            <span class="string">'[0-9]&#123;4&#125;/[0-9]&#123;2&#125;/[0-9]&#123;2&#125;/[0-9]&#123;2&#125;/[0-9]&#123;2&#125;/[0-9]&#123;2&#125;'</span>,</span><br><span class="line">            self._img_link)[<span class="number">0</span>]</span><br><span class="line">        img_name = re.findall(<span class="string">'[0-9]&#123;8&#125;'</span>, self._img_link)[<span class="number">0</span>]</span><br><span class="line">        file_addr = self._image_addr + img_name + <span class="string">'.jpg'</span></span><br><span class="line">        large_img_link = <span class="string">f'https://i.pximg.net/img-master/img/<span class="subst">&#123;img_date&#125;</span>/<span class="subst">&#123;img_name&#125;</span>_p0_master1200.jpg'</span></span><br><span class="line">        <span class="keyword">if</span> path.exists(file_addr):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        referer = <span class="string">f'https://www.pixiv.net/artworks/<span class="subst">&#123;img_name&#125;</span>'</span></span><br><span class="line">        req = requests.get(large_img_link, headers=&#123;<span class="string">'referer'</span>: referer&#125;)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fs = open(file_addr, <span class="string">'wb'</span>)</span><br><span class="line">            fs.write(req.content)</span><br><span class="line">        <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            fs.close()</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;img_name&#125;</span>.jpg 下载完成'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixiv</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, before_days=<span class="number">0</span>, page=<span class="number">1</span>, ranking_mode=<span class="string">'daily'</span>, lang=<span class="string">'zh'</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._before_days = before_days</span><br><span class="line">        self._page = page</span><br><span class="line">        self._ranking_addr = <span class="string">'https://www.pixiv.net/ranking.php'</span></span><br><span class="line">        self._ranking_mode = ranking_mode</span><br><span class="line">        self._lang = lang</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索图片，返回一个包含图片数据的列表（每一页60条）end_page如果等于0，意味着返回所有的图片，否则返回指定页数的图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_image</span><span class="params">(self, keyword, end_page=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> end_page == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 这里通过请求指定网站，获取总页数</span></span><br><span class="line">            get_total_req = requests.get(</span><br><span class="line">                <span class="string">f'https://www.pixiv.net/ajax/search/artworks/<span class="subst">&#123;keyword&#125;</span>?word=<span class="subst">&#123;keyword&#125;</span>&amp;order=date_d&amp;mode=all&amp;p=1&amp;s_mode=s_tag&amp;type=all&amp;lang=zh'</span></span><br><span class="line">            )</span><br><span class="line">            total_image = json.loads(</span><br><span class="line">                get_total_req.text)[<span class="string">'body'</span>][<span class="string">'illustManga'</span>][<span class="string">'total'</span>]</span><br><span class="line">            end_page = ceil(int(total_image) // <span class="number">60</span>)</span><br><span class="line">        total_image_array = []</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, end_page + <span class="number">1</span>):</span><br><span class="line">            search_link = <span class="string">f'https://www.pixiv.net/ajax/search/artworks/'</span> + keyword</span><br><span class="line">            params = &#123;</span><br><span class="line">                <span class="string">'word'</span>: keyword,</span><br><span class="line">                <span class="string">'order'</span>: <span class="string">'date_d'</span>,</span><br><span class="line">                <span class="string">'mode'</span>: <span class="string">'all'</span>,</span><br><span class="line">                <span class="string">'p'</span>: page,</span><br><span class="line">                <span class="string">'s_mode'</span>: <span class="string">'s_tag'</span>,</span><br><span class="line">                <span class="string">'type'</span>: <span class="string">'all'</span>,</span><br><span class="line">                <span class="string">'lang'</span>: <span class="string">'zh'</span></span><br><span class="line">            &#125;</span><br><span class="line">            req = requests.get(search_link, params=params)</span><br><span class="line">            images = json.loads(req.text)[<span class="string">'body'</span>][<span class="string">'illustManga'</span>][<span class="string">'data'</span>]</span><br><span class="line">            <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">                total_image_array.append(image[<span class="string">'url'</span>])</span><br><span class="line">        <span class="keyword">return</span> total_image_array</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回排名页全部图片的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ranking_image</span><span class="params">(self)</span>:</span></span><br><span class="line">        ranking_date = self.get_time()</span><br><span class="line">        ranking_image_attr = []</span><br><span class="line">        <span class="keyword">for</span> date <span class="keyword">in</span> range(int(ranking_date[<span class="number">0</span>]), int(ranking_date[<span class="number">1</span>]) + <span class="number">1</span>):</span><br><span class="line">            ranking_image_attr += self.ranking_page_image(date)</span><br><span class="line">        <span class="keyword">return</span> ranking_image_attr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于下载列表中的图片</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_image</span><span class="params">(self, image_array)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> image_link <span class="keyword">in</span> image_array:</span><br><span class="line">            DownloadImg(image_link).start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回排名页一页图片的链接列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ranking_page_image</span><span class="params">(self, date)</span>:</span></span><br><span class="line">        image_addr = []  <span class="comment"># 图片的链接地址都储存在这个数组中</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, self._page + <span class="number">1</span>):</span><br><span class="line">            params = &#123;</span><br><span class="line">                <span class="string">'mode'</span>: self._ranking_mode,</span><br><span class="line">                <span class="string">'date'</span>: str(date),</span><br><span class="line">                <span class="string">'p'</span>: page,</span><br><span class="line">                <span class="string">'format'</span>: <span class="string">'json'</span></span><br><span class="line">            &#125;</span><br><span class="line">            req = requests.get(self._ranking_addr, params=params)</span><br><span class="line">            image_list = json.loads(req.text)[<span class="string">'contents'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> image_element <span class="keyword">in</span> image_list:</span><br><span class="line">                image_addr.append(image_element[<span class="string">'url'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image_addr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取日期 [20200518, 20200518] 或 [20200517, 20200518] 后一个数永远是当天，前一个数根据日期差值计算得到的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(self)</span>:</span></span><br><span class="line">        tm = time.time()</span><br><span class="line">        <span class="comment"># 5月19日只有5月18日的排行榜</span></span><br><span class="line">        today = int(time.strftime(<span class="string">"%Y%m%d"</span>, time.gmtime(tm))) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._before_days == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [today, today]</span><br><span class="line">        before = today - self._before_days</span><br><span class="line">        <span class="keyword">return</span> [before, today]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># p1 = Pixiv(2, 2)</span></span><br><span class="line">    <span class="comment"># img_array = p1.ranking_image()</span></span><br><span class="line">    <span class="comment"># p1.download_image(img_array)</span></span><br><span class="line"></span><br><span class="line">    p2 = Pixiv()</span><br><span class="line">    p2.search_image(<span class="string">'タイツ'</span>, <span class="number">1</span>)</span><br><span class="line">    p2.download_image(img_array)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="遇到的难点"><a href="#遇到的难点" class="headerlink" title="遇到的难点"></a>遇到的难点</h4><ol><li>p 站有墙</li><li>高清图需要登录</li><li>套图只能拿到封面那一张图</li><li>搜索功能，高清图这些很有可能会依靠 cookie 来扩大搜索范围</li><li>需要手动在指定目录新建文件夹</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天对 pixiv 插画网站进行了爬虫尝试，下面是对这次爬虫的记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;网站情况&quot;&gt;&lt;a href=&quot;#网站情况&quot; class=&quot;headerlink&quot; title=&quot;网站情况&quot;&gt;&lt;/a&gt;网站情况&lt;/
      
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一次爬虫的记录</title>
    <link href="http://yoursite.com/2020/05/12/%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/12/%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%9A%84%E8%AE%B0%E5%BD%95/</id>
    <published>2020-05-12T14:58:51.000Z</published>
    <updated>2020-05-13T17:10:21.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前一直想爬一下 bing 的壁纸，不过那时候不太懂爬虫，而且没有找到有效的网址，导致最后也没有拿下来。最近在学习 python，刚好学到爬虫这里，想起了 bing，就尝试了一下。最终终于成功的将 bing 的壁纸爬取下来。以下是对这次爬虫代码的记录。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;pid=hp</span></span><br><span class="line"><span class="comment"># idx表示从今天起往前推几天，最多idx=7</span></span><br><span class="line"><span class="comment"># n表示最多一次性显示几条，最多8条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    bing_home = <span class="string">'https://cn.bing.com'</span></span><br><span class="line">    link = <span class="string">'https://cn.bing.com/HPImageArchive.aspx?format=js&amp;pid=hp&amp;n=8'</span></span><br><span class="line">    req = requests.get(link)</span><br><span class="line">    bing_information = json.loads(req.text)[<span class="string">'images'</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fs = open(<span class="string">'bing_img.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> bing_information:</span><br><span class="line">            img_link = bing_home + index[<span class="string">'url'</span>]</span><br><span class="line">            img_name = index[<span class="string">'startdate'</span>] + <span class="string">'.jpg'</span></span><br><span class="line">            img_req = requests.get(img_link)</span><br><span class="line">            img = open(img_name, <span class="string">'wb'</span>)</span><br><span class="line">            img.write(img_req.content)</span><br><span class="line">            fs.write(<span class="string">f'''</span></span><br><span class="line"><span class="string">startdate: <span class="subst">&#123;index[<span class="string">'startdate'</span>]&#125;</span></span></span><br><span class="line"><span class="string">copyright: <span class="subst">&#123;index[<span class="string">'copyright'</span>]&#125;</span></span></span><br><span class="line"><span class="string">copyrightlink: <span class="subst">&#123;img_link&#125;</span></span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        fs.close()</span><br><span class="line">        print(<span class="string">'保存完毕'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这里只是用了最简单的方式对 bing 的壁纸进行爬取，并没有使用到多进程，所以爬取速度比较的慢。而且 bing 的壁纸是利用 ajax 进行加载的，在请求的过程中可以直接找到 json 数据，加上 bing 自身并没有做反爬的设计，所以才能比较轻松的爬取到想要的数据。</p><blockquote><p>5 月 13 日更新，考虑了多线程，引入了 Thread 模块，使得下载图片的速度大大提升。并且利用正则表达式，从链接中提取图片的名字，用于已下载下来的图片的命名</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> ROOT</span><br><span class="line">ROOT = <span class="string">'/Users/Administrator/Desktop/picture/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadHandler</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 用于补全链接</span></span><br><span class="line">        bing_home = <span class="string">'https://cn.bing.com'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理文件名，应该可以直接用正则表达式解决的</span></span><br><span class="line">        filename_regexp = re.compile(<span class="string">'OHR\.(.*?)_ZH.*?_1920x1080(.jpg)'</span>)</span><br><span class="line">        filename = re.findall(filename_regexp, self._url)[<span class="number">0</span>]</span><br><span class="line">        filename = filename[<span class="number">0</span>] + filename[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 请求并保存图片</span></span><br><span class="line">        req = requests.get(bing_home + self._url)</span><br><span class="line">        <span class="keyword">with</span> open(ROOT + filename, <span class="string">'wb'</span>) <span class="keyword">as</span> fs:</span><br><span class="line">            fs.write(req.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    link = <span class="string">'https://cn.bing.com/HPImageArchive.aspx?format=js&amp;pid=hp&amp;n=8'</span></span><br><span class="line">    req = requests.get(link)</span><br><span class="line">    bing_information = json.loads(req.text)[<span class="string">'images'</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fs = open(ROOT + <span class="string">'bing_img.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> bing_information:</span><br><span class="line">            DownloadHandler(index[<span class="string">'url'</span>]).start()</span><br><span class="line">            fs.write(<span class="string">f'''</span></span><br><span class="line"><span class="string">            startdate: <span class="subst">&#123;index[<span class="string">'startdate'</span>]&#125;</span></span></span><br><span class="line"><span class="string">            copyright: <span class="subst">&#123;index[<span class="string">'copyright'</span>]&#125;</span></span></span><br><span class="line"><span class="string">            copyrightlink: <span class="subst">&#123;index[<span class="string">'url'</span>]&#125;</span></span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        fs.close()</span><br><span class="line">        print(<span class="string">'下载完成'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以前一直想爬一下 bing 的壁纸，不过那时候不太懂爬虫，而且没有找到有效的网址，导致最后也没有拿下来。最近在学习 python，刚好学到爬虫这里，想起了 bing，就尝试了一下。最终终于成功的将 bing 的壁纸爬取下来。以下是对这次爬虫代码的记
      
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode习题5</title>
    <link href="http://yoursite.com/2019/11/11/leetcode%E4%B9%A0%E9%A2%985/"/>
    <id>http://yoursite.com/2019/11/11/leetcode%E4%B9%A0%E9%A2%985/</id>
    <published>2019-11-11T01:30:44.000Z</published>
    <updated>2019-11-11T03:45:54.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="寻找两个有序数组的中位数"><a href="#寻找两个有序数组的中位数" class="headerlink" title="寻找两个有序数组的中位数"></a>寻找两个有序数组的中位数</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组  nums1 和  nums2。<br><br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。<br><br>你可以假设  nums1  和  nums2  不会同时为空。</p></blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr = [...nums1, ...nums2].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="keyword">const</span> middle = arr.length / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> (~~middle === middle) &#123;</span><br><span class="line"><span class="keyword">return</span> (arr[middle - <span class="number">1</span>] + arr[middle]) / <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr[~~middle]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> resArr = []</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length) &#123;</span><br><span class="line"><span class="keyword">const</span> arr = [s.charAt(i)]</span><br><span class="line"><span class="keyword">let</span> otherStr = s.substr(i + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 先找出与起始字符相同的字符的位置，返回从起始字符到相同字符中间的所有字符</span></span><br><span class="line"><span class="keyword">while</span> (otherStr.indexOf(s.charAt(i)) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> endPos = otherStr.indexOf(s.charAt(i))</span><br><span class="line">arr.push(otherStr.substr(<span class="number">0</span>, endPos + <span class="number">1</span>))</span><br><span class="line">otherStr = otherStr.substr(endPos + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是回文序列</span></span><br><span class="line"><span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> str = arr.join(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">let</span> reverseStr = str</span><br><span class="line">.split(<span class="string">''</span>)</span><br><span class="line">.reverse()</span><br><span class="line">.join(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (str === reverseStr) &#123;</span><br><span class="line">resArr.push(str)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr.pop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是最长的回文序列</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="string">''</span></span><br><span class="line">resArr.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val.length &gt; res.length) &#123;</span><br><span class="line">res = val</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法比较暴力，效率低，虽然能算出来结果，但用时较长，不能通过 leetcode 测试。因此改用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s || !s.trim()) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (s.length === <span class="number">1</span>) <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">if</span> (s.length === <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] === s[<span class="number">1</span>] ? s[<span class="number">0</span>] + s[<span class="number">1</span>] : s[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line"><span class="comment">// 扩散坐标</span></span><br><span class="line"><span class="comment">// 从left和right开始，分别向左和右进行扩散，判断是否是回文序列</span></span><br><span class="line"><span class="keyword">var</span> calPalindromeIndex = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = s.length</span><br><span class="line"><span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">left--</span><br><span class="line">right++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">left</span>: left + <span class="number">1</span>, <span class="attr">right</span>: right &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = s.length; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> even = <span class="string">''</span></span><br><span class="line"><span class="keyword">let</span> odd = <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//经过当前位与下一位判断已构成回文，扩散位直接从下一位开始，可以提速</span></span><br><span class="line"><span class="keyword">let</span> evenIndex = calPalindromeIndex(i - <span class="number">1</span>, i + <span class="number">2</span>, s)</span><br><span class="line">even = s.slice(evenIndex.left, evenIndex.right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oddIndex = calPalindromeIndex(i - <span class="number">1</span>, i + <span class="number">1</span>, s)</span><br><span class="line">odd = s.slice(oddIndex.left, oddIndex.right)</span><br><span class="line"><span class="keyword">let</span> re = odd.length &gt; even.length ? odd : even</span><br><span class="line">result = result.length &gt; re.length ? result : re</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h3><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行  Z 字形排列。<br><br>比如输入字符串为 “LEETCODEISHIRING”  行数为 3 时，排列如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br><br>请你实现这个将字符串进行指定行数变换的函数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例  1:"></a>示例  1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例  2:"></a>示例  2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numRows === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (numRows === <span class="number">1</span>) <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">var</span> isDown = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> nowRow = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows).fill(<span class="string">''</span>)</span><br><span class="line">array.forEach.call(s, val =&gt; &#123;</span><br><span class="line">array[nowRow] += val</span><br><span class="line"><span class="keyword">if</span> (nowRow === numRows - <span class="number">1</span>) &#123;</span><br><span class="line">isDown = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowRow === <span class="number">0</span>) &#123;</span><br><span class="line">isDown = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">nowRow += isDown ? <span class="number">1</span> : <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> array.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;寻找两个有序数组的中位数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序
      
    
    </summary>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/categories/leetcode%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/tags/leetcode%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode习题4</title>
    <link href="http://yoursite.com/2019/11/10/leetcode%E4%B9%A0%E9%A2%984/"/>
    <id>http://yoursite.com/2019/11/10/leetcode%E4%B9%A0%E9%A2%984/</id>
    <published>2019-11-10T11:47:42.000Z</published>
    <updated>2019-11-10T12:44:19.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><blockquote><p>给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。<br><br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line"><span class="keyword">return</span> [i, j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><blockquote><p>给出两个   非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照   逆序   的方式存储的，并且它们的每个节点只能存储   一位   数字。<br><br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br><br>您可以假设除了数字 0 之外，这两个数都不会以 0  开头。</p></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> p1 = l1</span><br><span class="line"><span class="keyword">let</span> p2 = l2</span><br><span class="line"><span class="keyword">let</span> carry = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> temp = <span class="keyword">new</span> ListNode()</span><br><span class="line"><span class="comment">// 指定当前链表节点</span></span><br><span class="line"><span class="keyword">let</span> pointer = temp</span><br><span class="line"><span class="comment">// 如果l1, l2还存在或者还存在进位数据</span></span><br><span class="line"><span class="keyword">while</span> (p1 || p2 || carry) &#123;</span><br><span class="line"><span class="keyword">const</span> num1 = p1 ? p1.val : <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> num2 = p2 ? p2.val : <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> sum = num1 + num2 + carry</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">9</span>) &#123;</span><br><span class="line">pointer.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>)</span><br><span class="line">carry = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pointer.next = <span class="keyword">new</span> ListNode(sum)</span><br><span class="line">carry = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动指针</span></span><br><span class="line"><span class="keyword">if</span> (p1) p1 = p1.next</span><br><span class="line"><span class="keyword">if</span> (p2) p2 = p2.next</span><br><span class="line">pointer = pointer.next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例  1:"></a>示例  1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是  &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">  请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;  是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><p>下面代码是我自己写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> resLen = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> strArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> pos = strArr.indexOf(s.charAt(i))</span><br><span class="line"><span class="keyword">if</span> (pos === <span class="number">-1</span>) &#123;</span><br><span class="line">strArr.push(s.charAt(i))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resLen = strArr.length &gt; resLen ? strArr.length : resLen</span><br><span class="line">strArr = [s.charAt(i)]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为我写的代码是正确的，也确实能计算出准确的数字。但力扣有一条测验，输入的字符是<code>&#39;&#39;</code>，要求输出是 1，我输出是 0。我是没太看明白，明明没有输入字符，为什么最长子串长度是 1。然后我把 resLen 的预设值改成了 1，结果他的测验输入字符还是<code>&#39;&#39;</code>，要求输出变成了 0，我输出了 1……我是没搞明白是怎么回事。所以还是参考别人的代码写了一下……下面是别人的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> (n <span class="keyword">of</span> s) &#123;</span><br><span class="line"><span class="keyword">if</span> (m.indexOf(n) == <span class="number">-1</span>) &#123;</span><br><span class="line">m += n</span><br><span class="line">num++</span><br><span class="line">res = res &lt; num ? num : res</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m += n</span><br><span class="line">m = m.slice(m.indexOf(n) + <span class="number">1</span>)</span><br><span class="line">num = m.length</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两
      
    
    </summary>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/categories/leetcode%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/tags/leetcode%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>欧拉计划3</title>
    <link href="http://yoursite.com/2019/11/09/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%923/"/>
    <id>http://yoursite.com/2019/11/09/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%923/</id>
    <published>2019-11-09T07:39:46.000Z</published>
    <updated>2019-11-10T11:06:37.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关卡-8：连续数字最大乘积"><a href="#关卡-8：连续数字最大乘积" class="headerlink" title="关卡 8：连续数字最大乘积"></a>关卡 8：连续数字最大乘积</h3><blockquote><p>在下面这个 1000 位正整数中，连续 4 个数字的最大乘积是 9 × 9 × 8 × 9 = 5832。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">73167176531330624919225119674426574742355349194934</span><br><span class="line">96983520312774506326239578318016984801869478851843</span><br><span class="line">85861560789112949495459501737958331952853208805511</span><br><span class="line">12540698747158523863050715693290963295227443043557</span><br><span class="line">66896648950445244523161731856403098711121722383113</span><br><span class="line">62229893423380308135336276614282806444486645238749</span><br><span class="line">30358907296290491560440772390713810515859307960866</span><br><span class="line">70172427121883998797908792274921901699720888093776</span><br><span class="line">65727333001053367881220235421809751254540594752243</span><br><span class="line">52584907711670556013604839586446706324415722155397</span><br><span class="line">53697817977846174064955149290862569321978468622482</span><br><span class="line">83972241375657056057490261407972968652414535100474</span><br><span class="line">82166370484403199890008895243450658541227588666881</span><br><span class="line">16427171479924442928230863465674813919123162824586</span><br><span class="line">17866458359124566529476545682848912883142607690042</span><br><span class="line">24219022671055626321111109370544217506941658960408</span><br><span class="line">07198403850962455444362981230987879927244284909188</span><br><span class="line">84580156166097919133875499200524063689912560717606</span><br><span class="line">05886116467109405077541002256983155200055935729725</span><br><span class="line">71636269561882670428252483600823257530420752963450</span><br></pre></td></tr></table></figure><blockquote><p>找出这个 1000 位正整数中乘积最大的连续 13 个数字。它们的乘积是多少？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestProductinaSeries</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> thousandDigits = [... ...]; <span class="comment">// 数字太多，省略掉了</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> product = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= thousandDigits.length - num; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> left = i</span><br><span class="line">    <span class="keyword">const</span> right = num + i</span><br><span class="line">    <span class="comment">// 判断在指定长度区间内是否存在0</span></span><br><span class="line">    <span class="keyword">if</span>(thousandDigits.slice(left, right).indexOf(<span class="number">0</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//没有0就可以计算乘积进行比较</span></span><br><span class="line">      product = thousandDigits.slice(left, right).reduce(<span class="function">(<span class="params">res, val</span>)=&gt;</span> res * val)</span><br><span class="line">      <span class="keyword">if</span>(product &gt; res)&#123;</span><br><span class="line">        res = product</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestProductinaSeries(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><h3 id="关卡-9：特殊毕达哥拉斯三元组"><a href="#关卡-9：特殊毕达哥拉斯三元组" class="headerlink" title="关卡 9：特殊毕达哥拉斯三元组"></a>关卡 9：特殊毕达哥拉斯三元组</h3><blockquote><p>毕达哥拉斯三元组是三个自然数 $a &lt; b &lt; c$ 组成的集合，并满足$a^2 + b^2 = c^2$，例如$3^2 + 4^2 = 9 + 16 = 25 = 5^2$，有且只有一个毕达哥拉斯三元组满足 a + b + c = 1000。求这个三元组的乘积 abc。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">specialPythagoreanTriplet</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">1</span>; a &lt; n / <span class="number">2</span>; a++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b = a + <span class="number">1</span>; b &lt; n / <span class="number">2</span>; b++) &#123;</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(a, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(b, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">if</span> (a + b + c === n) &#123;</span><br><span class="line">res = a * b * c</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">specialPythagoreanTriplet(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="关卡-10：素数的和"><a href="#关卡-10：素数的和" class="headerlink" title="关卡 10：素数的和"></a>关卡 10：素数的和</h3><blockquote><p>所有小于 10 的素数的和是 2 + 3 + 5 + 7 = 17。<br><br>求所有小于给定参数值 n 的素数的和。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">primeSummation</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> resArr = [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">2</span></span><br><span class="line"><span class="comment">// 只计算奇数部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n / <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (resArr[pos - <span class="number">2</span>] === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += pos</span><br><span class="line"><span class="keyword">let</span> k = pos</span><br><span class="line"><span class="keyword">while</span> (pos * k &lt;= n) &#123;</span><br><span class="line">resArr[pos * k - <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">k = k + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">primeSummation(<span class="number">2000000</span>)</span><br></pre></td></tr></table></figure><p>虽然上面方法对算法进行了优化，但仍因计算时间较长无法通过测试，后续使用其他算法通过测试后会在下面进行更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关卡-8：连续数字最大乘积&quot;&gt;&lt;a href=&quot;#关卡-8：连续数字最大乘积&quot; class=&quot;headerlink&quot; title=&quot;关卡 8：连续数字最大乘积&quot;&gt;&lt;/a&gt;关卡 8：连续数字最大乘积&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在下面这个 1000 位正
      
    
    </summary>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/categories/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/tags/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>欧拉计划2</title>
    <link href="http://yoursite.com/2019/11/08/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%922/"/>
    <id>http://yoursite.com/2019/11/08/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%922/</id>
    <published>2019-11-08T10:47:26.000Z</published>
    <updated>2019-11-09T07:38:07.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关卡-5：最小倍数"><a href="#关卡-5：最小倍数" class="headerlink" title="关卡 5：最小倍数"></a>关卡 5：最小倍数</h3><blockquote><p>2520 是最小的能够被 1 到 10 整除的数。<br><br>最小的能够被 1 到 20 整除的正数是多少？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">smallestMult</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 预先设置数组用于储存分解的因数</span></span><br><span class="line"><span class="keyword">const</span> resArr = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> temp = n</span><br><span class="line"><span class="keyword">let</span> skip = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 先参考因数数组分解当前数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; resArr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp % resArr[j] === <span class="number">0</span>) &#123;</span><br><span class="line">temp /= resArr[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果temp === 1， 说明最终乘积为当前数的整数倍</span></span><br><span class="line"><span class="keyword">if</span> (temp === <span class="number">1</span>) &#123;</span><br><span class="line">skip = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n--</span><br><span class="line"><span class="keyword">if</span> (skip) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前数字存在不包含在因数数组中的因数</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> (temp &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 将因数数组中没有包含到的因数补全</span></span><br><span class="line"><span class="keyword">if</span> (temp % k === <span class="number">0</span>) &#123;</span><br><span class="line">temp /= k</span><br><span class="line">resArr.push(k)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算因数数组的总乘积</span></span><br><span class="line"><span class="keyword">return</span> resArr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total * num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smallestMult(<span class="number">20</span>) <span class="comment">// 232792560</span></span><br></pre></td></tr></table></figure><h3 id="关卡-6：平方的和与和的平方之差"><a href="#关卡-6：平方的和与和的平方之差" class="headerlink" title="关卡 6：平方的和与和的平方之差"></a>关卡 6：平方的和与和的平方之差</h3><blockquote><p>前十个自然数的平方的和是<br><br>$1^2 + 2^2 + … + 10^2 = 385$<br><br>前十个自然数的和的平方是<br><br>$(1 + 2 + … + 10)^2 = 552 = 3025$<br><br>因此前十个自然数的平方的和与和的平方之差是 $3025 − 385 = 2640$。<br><br>求前一百个自然数的平方的和与和的平方之差。</p></blockquote><p>$1^2+2^2+\cdots+x^2 = \frac{1}{6}x(x+1)(2x+1)$</p><p>$(1+2+\cdots+x)^2 = \left[\frac{(1 + x)x}{2}\right]^2$</p><p>$\left[\frac{(1 + x)x}{2}\right]^2 - \frac{1}{6}x(x+1)(2x+1) = \frac{x(x + 1)(x - 1)(3x + 2)}{12}$</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSquareDifference</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (num * (num + <span class="number">1</span>) * (num - <span class="number">1</span>) * (<span class="number">3</span> * num + <span class="number">2</span>)) / <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是通过预先计算得到，如果不预先计算可以使用下面方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSquareDifference</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">res += i</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">Math</span>.pow(res, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= num; j++) &#123;</span><br><span class="line">res -= <span class="built_in">Math</span>.pow(j, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumSquareDifference(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="关卡-7：第-10001-个素数"><a href="#关卡-7：第-10001-个素数" class="headerlink" title="关卡 7：第 10001 个素数"></a>关卡 7：第 10001 个素数</h3><blockquote><p>列出前 6 个素数，它们分别是 2、3、5、7、11 和 13。我们可以看出，第 6 个素数是 13。<br><br>第 10,001 个素数是多少？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>]</span><br><span class="line"><span class="keyword">while</span> (arr.length &lt; number) &#123;</span><br><span class="line">pos++</span><br><span class="line"><span class="keyword">if</span> (isPrime(pos)) &#123;</span><br><span class="line">arr.push(pos)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr.reverse()[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(num))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= sqrt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nthPrime(<span class="number">10001</span>) <span class="comment">// 104743</span></span><br></pre></td></tr></table></figure><p>上方法虽然可以计算出第 10001 位素数，但无法通过 FCC 验证，因为每一个数都要进行素数验证，导致需要额外生成很多循环。为了减少计算量，这里使用<a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin" target="_blank" rel="noopener">埃拉托斯特尼筛法<br></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> limit = <span class="number">110000</span></span><br><span class="line"><span class="comment">// 预先生成一个指定长度的空数组</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(limit)</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j &lt;= limit; j++) &#123;</span><br><span class="line"><span class="comment">// 如果是已知素数的倍数，会被标记成0， 没有被标记的就是新的素数</span></span><br><span class="line"><span class="comment">// 数组arr第一个数字为2，位置是0，所以数字跟对应位置之间差2</span></span><br><span class="line"><span class="keyword">if</span> (arr[j - <span class="number">2</span>] === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 保存素数</span></span><br><span class="line">arr[j - <span class="number">2</span>] = j</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">if</span> (count === number) &#123;</span><br><span class="line"><span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记当前素数的所有倍数</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> (j * k &lt;= limit) &#123;</span><br><span class="line">arr[j * k - <span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nthPrime(<span class="number">10001</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关卡-5：最小倍数&quot;&gt;&lt;a href=&quot;#关卡-5：最小倍数&quot; class=&quot;headerlink&quot; title=&quot;关卡 5：最小倍数&quot;&gt;&lt;/a&gt;关卡 5：最小倍数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2520 是最小的能够被 1 到 10 整除的数。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/categories/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/tags/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode习题3</title>
    <link href="http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%983/"/>
    <id>http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%983/</id>
    <published>2019-11-07T08:36:25.000Z</published>
    <updated>2019-11-10T11:47:57.119Z</updated>
    
    <content type="html"><![CDATA[<p>这次的题全军覆没很难受ヾ(。￣ □ ￣)ﾂ゜゜゜，我还是记录一下别人的解题方法吧……</p><h3 id="Number-of-Islands-岛屿数量"><a href="#Number-of-Islands-岛屿数量" class="headerlink" title="Number of Islands 岛屿数量"></a>Number of Islands 岛屿数量</h3><blockquote><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p></blockquote><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>对这个矩阵进行循环访问每一个点；<br>当这个点等于 1，岛屿数量 count++，与其同时用 dfs 算法（depth first search）访问周围的其他点，进行同样的操作；<br>且将访问过且等于 1 的点标记为零。</p><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 岛屿数量</span></span><br><span class="line"><span class="keyword">if</span> (grid.length === <span class="number">0</span>) <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] === <span class="string">'1'</span>) &#123;</span><br><span class="line">dfsSearch(grid, i, j)</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsSearch</span>(<span class="params">grid, i, j</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> (grid[i][j] === <span class="string">'1'</span>) &#123;</span><br><span class="line">grid[i][j] = <span class="string">'0'</span></span><br><span class="line">dfsSearch(grid, i + <span class="number">1</span>, j) <span class="comment">// 搜索右边</span></span><br><span class="line">dfsSearch(grid, i - <span class="number">1</span>, j) <span class="comment">// 搜索左边</span></span><br><span class="line">dfsSearch(grid, i, j + <span class="number">1</span>) <span class="comment">// 搜索下边</span></span><br><span class="line">dfsSearch(grid, i, j - <span class="number">1</span>) <span class="comment">// 搜索上边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="香槟塔"><a href="#香槟塔" class="headerlink" title="香槟塔"></a>香槟塔</h3><blockquote><p>我们把玻璃杯摆成金字塔的形状，其中第一层有 1 个玻璃杯，第二层有 2 个，依次类推到第 100 层，每个玻璃杯(250ml)将盛有香槟。<br><br>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）<br><br>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p></blockquote><img src="https://icelicecream.github.io/image/香槟塔1.png"><h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="line">输出: 0.0</span><br><span class="line">解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br></pre></td></tr></table></figure><h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span><br><span class="line">输出: 0.5</span><br><span class="line">解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>假设倒入 20 杯酒，每个杯子停留的酒数量有：</p><img src="https://icelicecream.github.io/image/香槟塔2.png"><p>第 0 层：<br>a[0][0] = 20</p><p>第一层：<br>a[1][0] = (a[0][0] - 1) / 2 = 4.5<br>a[1][1] = (a[0][0] - 1) / 2 = 4.5</p><p>第二层：<br>a[2][0] = (a[1][0]-1) / 2<br>a[2][1] = (a[1][0]-1) / 2 + (a[1][1]-1) / 2<br>a[2][2] = (a[1][1]-1) / 2</p><p>第三层：<br>a[3][0] = (a[2][0]-1)/2<br>a[3][1] = (a[2][0]-1)/2 + (a[2][1]-1)/2<br>a[3][2] = (a[2][1]-1)/2 + (a[2][2]-1)/2<br>a[3][3] = (a[2][2]-1)/2</p><p>第四层：<br>a[4][0] = (a[3][0]-1)/2<br>a[4][1] = (a[3][0]-1)/2 + (a[3][1]-1)/2<br>a[4][2] = (a[3][1]-1)/2 + (a[3][2]-1)/2<br>a[4][3] = (a[3][2]-1)/2 + (a[3][3]-1)/2<br>a[4][3] = (a[3][3]-1)/2</p><p>第 N 层：<br>a[N][0] = (a[N-1][0] - 1)/2<br>a[N][1] = (a[N-1][0] - 1)/2 + (a[N-1][1] - 1)/2<br>a[N][n] = (a[N-1][n-1] - 1) /2</p><p>通过上面，可以推导出第 query_row 层，query_glass 位置的酒杯中酒的分量为：<br>a[query_row][query_glass] = (a[query_row - 1][query_glass-1] - 1) /2 + (a[query_row - 1][query_glass] - 1) /2</p><p>ps：这是假设计算过程中不存在负数的情况 ，实际程序中需要考虑负数场景。</p><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">champagneTower</span>(<span class="params">poured, query_row, query_glass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="comment">// 生成一个矩阵，并将矩阵内所有数字设为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; query_row + <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> temp = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; query_row + <span class="number">2</span>; j++) &#123;</span><br><span class="line">temp.push(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">arr.push(temp)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = poured</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; query_row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">const</span> remain = (arr[i][j] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(remain)</span><br><span class="line"><span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">arr[i + <span class="number">1</span>][j] += remain</span><br><span class="line">arr[i + <span class="number">1</span>][j + <span class="number">1</span>] += remain</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[query_row][query_glass] &gt; <span class="number">1</span> ? <span class="number">1</span> : arr[query_row][query_glass]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a>最短回文串</h3><blockquote><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p></blockquote><h4 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aacecaaa&quot;</span><br><span class="line">输出: &quot;aaacecaaa&quot;</span><br></pre></td></tr></table></figure><h4 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcd&quot;</span><br><span class="line">输出: &quot;dcbabcd&quot;</span><br></pre></td></tr></table></figure><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>网上提供了三种方法：暴力破解法、递归法和 KMP 算法。暴力破解法不用过多解释，就是想尽所有可能性。下面就说一下递归法和 KMP 法</p><h5 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h5><p>左指针 i 初始化为 0，右指针 j 从 n - 1 递减到 0，其中 n 为字符串 s 的长度，一旦遇上 i 指向的字符与 j 指向的字符相等时，令 i 指针加 1。</p><p>递归出口：</p><p>如果 i 指针最后的值等于 n，说明字符串 s 本身就是回文串，直接返回 s 即可。</p><p>递归过程：</p><p>首先明确一点：我们所要寻找的最长回文子串，该子串的左端点与字符串 s 的左端点重合，一定在[0, i)范围内。</p><p>考虑两种极端情况，第一种情况：字符串 s 本身就是回文串，显然满足条件。第二种情况：在遍历过程中，不存在 i 指向的字符与 j 指向的字符相等的情况，除了 i 和 j 相等时，这种情况我们得到的 i 是 1。显然也满足条件。</p><p>考虑一般性情况：假设我们所要寻找的最长回文子串不在[0, i)范围内，即存在回文串其在[0, k)范围内，其中 k &gt; i。那么显然，在我们遍历的过程中，即使 j 在[k, n - 1]范围时不存在 i 指向的字符与 j 指向的字符相等的情况，最终 i 的值也会到达 k，即 i &gt;= k，这显然矛盾了，因此该结论成立。</p><p>由上述结论，我们得出：[i, n - 1]范围内的子串一定不是我们所要寻找的最长回文子串的一部分。</p><p>这样，我们就可以递归地反转[0, i)范围内的子串来拼接出结果。</p><h5 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h5><p>将原字符串 s 和其逆序字符串用“#”拼接在一起，利用 KMP 算法中 next 数组的求法求得拼接出的新字符串的最长相同前后缀，就是原字符串 s 中最长的回文子串，该子串的左端点与字符串 s 的左端点重合。</p><p>这个问题是一个动态规划问题：求取字符串 s 中的最长相同前后缀（不能是其本身）</p><p>状态定义：</p><p>f(x) ——– 字符串 s 中[0, x]范围内的最长相同前后缀（不能是其本身）的长度</p><p>状态转移：</p><p>首先是初始化，f(0)显然是 0，因为[0, 0]范围内的字符串长度为 1，其最长相同前后缀根本不存在。</p><p>对于 i 在[1, n - 1]（其中 n 为字符串 s 的长度）范围内的值：</p><p>（1）令 temp 记录 f(x - 1)的值，如果 temp 大于 0 且 s 中 temp 位置的字符和第 i 个字符不相同，那么我们就需要重设 temp 的值为 f(temp - 1)。</p><p>（2）如果 s 中第 i 个字符与第 temp 个字符相同，令 temp 自增 1。</p><p>（3）f(i) = temp。</p><p>上述状态转移过程可能很难理解，以一个例子——“ABABCABAA”来说明，其子串如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A -------------------------------------------------- 0</span><br><span class="line">AB ------------------------------------------------ 0</span><br><span class="line">ABA ---------------------------------------------- 1</span><br><span class="line">ABAB -------------------------------------------- 2</span><br><span class="line">ABABC ------------------------------------------ 0</span><br><span class="line">ABABCA ---------------------------------------- 1</span><br><span class="line">ABABCAB -------------------------------------- 2</span><br><span class="line">ABABCABA ------------------------------------ 3</span><br><span class="line">ABABCABAA ---------------------------------- 1</span><br></pre></td></tr></table></figure><p>对由 ABAB 求得 ABABC 这个过程进行分析：</p><p>C 和 A 不相等，因此结果不可能是 3，如果是 ABABA，则结果是 3。ABAB 的结果是 2，因此我们知道 AB 和 AB 相同，但是第一个 AB 之后跟着的是 A，依然和 C 不相同。我们继续看 AB，AB 的结果是 0，因此我们知道 AB 中 A 和 B 不相同，而 C 和 A 不相同，因此结果是 0。</p><p>对由 ABABCABA 求得 ABABCABAA 这个过程进行分析：</p><p>A 和 B 不相等，因此结果不可能是 4，如果是 ABABCABAB，则结果是 4。ABABCABA 的结果是 3，因此我们知道 ABA 和 ABA 相同，但是第一个 ABA 之后跟着的是 B，依然和 A 不相同。我们继续看 ABA，ABA 的结果是 1，但是第一个 A 之后跟着的是 B，依然和 A 不相同。我们继续看 A，结果是 0，结束 while 循环。这个 A 和 A 相同，因此其值加 1 变成 1。</p><p>时间复杂度和空间复杂度均是 O(n)，其中 n 为字符串 s 的长度。</p><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><p>暴力破解法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shortestPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPalindrome(s.substr(<span class="number">0</span>, i + <span class="number">1</span>))) &#123;</span><br><span class="line">index = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = reverse(s.substr(index + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> res + s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...s].reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) !== s.charAt(s.length - <span class="number">1</span> - i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shortestPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = s.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(j) === s.charAt(index)) &#123;</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index === s.length) &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">reverse(s.substr(index)) +</span><br><span class="line">shortestPalindrome(s.substr(<span class="number">0</span>, index)) +</span><br><span class="line">s.substr(index)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...s].reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP 算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shortestPalindrome</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> rev = reverse(s)</span><br><span class="line"><span class="keyword">const</span> temp = s + <span class="string">'#'</span> + rev</span><br><span class="line"><span class="keyword">const</span> next = getNext(temp)</span><br><span class="line"><span class="built_in">console</span>.log(next)</span><br><span class="line"><span class="keyword">return</span> rev.substr(<span class="number">0</span>, rev.length - next[temp.length - <span class="number">1</span>]) + s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...s].reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(s.length)</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; res.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> temp = res[i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> (temp &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) !== s.charAt(temp)) &#123;</span><br><span class="line">temp = res[temp - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) === s.charAt(temp)) &#123;</span><br><span class="line">temp++</span><br><span class="line">&#125;</span><br><span class="line">res[i] = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次的题全军覆没很难受ヾ(。￣ □ ￣)ﾂ゜゜゜，我还是记录一下别人的解题方法吧……&lt;/p&gt;
&lt;h3 id=&quot;Number-of-Islands-岛屿数量&quot;&gt;&lt;a href=&quot;#Number-of-Islands-岛屿数量&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/categories/leetcode%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/tags/leetcode%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode习题2</title>
    <link href="http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%982/"/>
    <id>http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%982/</id>
    <published>2019-11-07T04:23:59.000Z</published>
    <updated>2019-11-08T02:55:26.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强整数"><a href="#强整数" class="headerlink" title="强整数"></a>强整数</h3><blockquote><p>给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i &gt;= 0 且 j &gt;= 0，那么我们认为该整数是一个强整数。<br><br>返回值小于或等于 bound 的所有强整数组成的列表。<br><br>你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。</p></blockquote><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2, y = 3, bound = 10</span><br><span class="line">输出：[2,3,4,5,7,9,10]</span><br><span class="line">解释：</span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 3, y = 5, bound = 15</span><br><span class="line">输出：[2,4,6,8,10,14]</span><br></pre></td></tr></table></figure><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> powerfulIntegers = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, bound</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> iMax = ~~(<span class="built_in">Math</span>.log(bound) / <span class="built_in">Math</span>.log(x))</span><br><span class="line"><span class="keyword">const</span> jMax = ~~(<span class="built_in">Math</span>.log(bound) / <span class="built_in">Math</span>.log(y))</span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line"><span class="keyword">while</span> (bound &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= iMax; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= jMax; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.pow(x, i) + <span class="built_in">Math</span>.pow(y, j) === bound) &#123;</span><br><span class="line">res.push(bound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bound--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [...new <span class="built_in">Set</span>(res.reverse())]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换成小写字母"><a href="#转换成小写字母" class="headerlink" title="转换成小写字母"></a>转换成小写字母</h3><blockquote><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p></blockquote><h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure><h4 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toLowerCase = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr = [...str]</span><br><span class="line">arr.map(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> ascii = val.charCodeAt()</span><br><span class="line"><span class="keyword">if</span> (ascii &lt; <span class="number">91</span> &amp;&amp; ascii &gt; <span class="number">64</span>) &#123;</span><br><span class="line">ascii += <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line">array[index] = <span class="built_in">String</span>.fromCharCode(ascii)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> arr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键值映射"><a href="#键值映射" class="headerlink" title="键值映射"></a>键值映射</h3><blockquote><p>实现一个 MapSum 类里的两个方法，insert 和 sum。<br><br>对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。<br><br>对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。</p></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: insert(&quot;apple&quot;, 3), 输出: Null</span><br><span class="line">输入: sum(&quot;ap&quot;), 输出: 3</span><br><span class="line">输入: insert(&quot;app&quot;, 2), 输出: Null</span><br><span class="line">输入: sum(&quot;ap&quot;), 输出: 5</span><br></pre></td></tr></table></figure><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MapSum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.obj = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MapSum.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.obj[key] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MapSum.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.obj)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">keys.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val.indexOf(prefix) === <span class="number">0</span>) &#123;</span><br><span class="line">sum += <span class="keyword">this</span>.obj[val]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强整数&quot;&gt;&lt;a href=&quot;#强整数&quot; class=&quot;headerlink&quot; title=&quot;强整数&quot;&gt;&lt;/a&gt;强整数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i &amp;gt;= 0 且 j &amp;
      
    
    </summary>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/categories/leetcode%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/tags/leetcode%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode习题1</title>
    <link href="http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%981/"/>
    <id>http://yoursite.com/2019/11/07/leetcode%E4%B9%A0%E9%A2%981/</id>
    <published>2019-11-07T04:14:30.000Z</published>
    <updated>2019-11-07T04:20:34.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较字符串最小字母出现频次"><a href="#比较字符串最小字母出现频次" class="headerlink" title="比较字符串最小字母出现频次"></a>比较字符串最小字母出现频次</h3><blockquote><p>我们来定义一个函数 f(s)，其中传入参数 s 是一个非空字符串；该函数的功能是统计 s 中（按字典序比较）最小字母的出现频次。<br><br>例如，若 s = “dcce”，那么 f(s) = 2，因为最小的字母是 “c”，它出现了 2 次。<br><br>现在，给你两个字符串数组待查表 queries 和词汇表 words，请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是满足 f(queries[i]) &lt; f(W) 的词的数目，W 是词汇表 words 中的词。</p></blockquote><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]</span><br><span class="line">输出：[1]</span><br><span class="line">解释：查询 f(&quot;cbd&quot;) = 1，而 f(&quot;zaaaz&quot;) = 3 所以 f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;)。</span><br></pre></td></tr></table></figure><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。</span><br></pre></td></tr></table></figure><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numSmallerByFrequency = <span class="function"><span class="keyword">function</span>(<span class="params">queries, words</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> wordsLen = words.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getNum(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> resArr = []</span><br><span class="line">queries.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> times = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> queryLen = getNum(val)</span><br><span class="line">wordsLen.map(<span class="function"><span class="params">wlen</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (queryLen &lt; wlen) &#123;</span><br><span class="line">times = times + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">resArr.push(times)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">let</span> temp = <span class="number">3000</span>,</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">strArr.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; val.charCodeAt()) &#123;</span><br><span class="line">temp = val.charCodeAt()</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == val.charCodeAt()) &#123;</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> tempWord = <span class="built_in">String</span>.fromCharCode(temp)</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复的-DNA-序列"><a href="#重复的-DNA-序列" class="headerlink" title="重复的 DNA 序列"></a>重复的 DNA 序列</h3><blockquote><p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。<br><br>编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。</p></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">输出：[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatedDnaSequences = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> list10 = DNALen10(s)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list10.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(list10[i])) &#123;</span><br><span class="line">obj[list10[i]] += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">obj[list10[i]] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj[key] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">res.push(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DNALen10</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">const</span> times = s.split(<span class="string">''</span>).length - <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">arr.push(s.slice(i, i + <span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较字符串最小字母出现频次&quot;&gt;&lt;a href=&quot;#比较字符串最小字母出现频次&quot; class=&quot;headerlink&quot; title=&quot;比较字符串最小字母出现频次&quot;&gt;&lt;/a&gt;比较字符串最小字母出现频次&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们来定义一个函数 f(s
      
    
    </summary>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/categories/leetcode%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="leetcode习题" scheme="http://yoursite.com/tags/leetcode%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>欧拉计划1</title>
    <link href="http://yoursite.com/2019/11/06/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%921/"/>
    <id>http://yoursite.com/2019/11/06/%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%921/</id>
    <published>2019-11-06T14:48:41.000Z</published>
    <updated>2019-11-08T02:56:04.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关卡-1：3-和-5-的倍数"><a href="#关卡-1：3-和-5-的倍数" class="headerlink" title="关卡 1：3 和 5 的倍数"></a>关卡 1：3 和 5 的倍数</h3><blockquote><p>如果我们列出 10 以内所有 3 或 5 的倍数，我们将得到 3、5、6 和 9，这些数的和是 23。<br><br>求给定参数值 n 以内的所有 3 或 5 的倍数的和。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplesOf3and5</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">number--</span><br><span class="line"><span class="keyword">if</span> (number % <span class="number">3</span> === <span class="number">0</span> || number % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">res += number</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiplesOf3and5(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="关卡-2：偶斐波那契数"><a href="#关卡-2：偶斐波那契数" class="headerlink" title="关卡 2：偶斐波那契数"></a>关卡 2：偶斐波那契数</h3><blockquote><p>斐波那契数列中的每一项都是前两项的和。 由 1 和 2 开始生成的斐波那契数列的前 10 项为：<br><br>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …<br><br>考虑该斐波那契数列中不超过四百万的项，求其中为偶数的项之和。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fiboEvenSum</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> before = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> next = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (number - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (next % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">res += next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换位</span></span><br><span class="line">next ^= before</span><br><span class="line">before ^= next</span><br><span class="line">next ^= before</span><br><span class="line"><span class="comment">// 累加</span></span><br><span class="line">next += before</span><br><span class="line">number--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fiboEvenSum(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="关卡-3：最大质因数"><a href="#关卡-3：最大质因数" class="headerlink" title="关卡 3：最大质因数"></a>关卡 3：最大质因数</h3><blockquote><p>13195 的所有质因数为 5、7、13 和 29。<br><br>600851475143 最大的质因数是多少？</p></blockquote><p>如果判断所有小于指定值的数是否因数，再去看那个因数是最大的素数，计算量会非常的大。为了减少计算量，这里采用因数分解的方式，一点一点减小需要计算的数的大小，同时也减少了计算量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestPrimeFactor</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (number % i === <span class="number">0</span>) &#123;</span><br><span class="line">number = number / i</span><br><span class="line">res = i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestPrimeFactor(<span class="number">13195</span>)</span><br></pre></td></tr></table></figure><h3 id="关卡-4：最大回文乘积"><a href="#关卡-4：最大回文乘积" class="headerlink" title="关卡 4：最大回文乘积"></a>关卡 4：最大回文乘积</h3><blockquote><p>回文数就是从前往后和从后往前读都一样的数。由两个 2 位数相乘得到的最大回文乘积是 9009 = 91 × 99。<br><br>找出由两个 3 位数相乘得到的最大回文乘积。</p></blockquote><p>这里如果不添加 max 对值进行比对，而是直接输出第一个遇到的回文乘积，结果是 888888，但如果添加了 max 进行前后值的比对，实际最大回文乘积为 906609</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">largestPalindromeProduct</span>(<span class="params">digit</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit) - <span class="number">1</span>; i &gt;= <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit - <span class="number">1</span>); i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit) - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPalindrome(i * j) &amp;&amp; i * j &gt; max) &#123;</span><br><span class="line">max = i * j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="built_in">parseInt</span>(</span><br><span class="line">num</span><br><span class="line">.toString()</span><br><span class="line">.split(<span class="string">''</span>)</span><br><span class="line">.reverse()</span><br><span class="line">.join(<span class="string">''</span>)</span><br><span class="line">) === num</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">largestPalindromeProduct(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关卡-1：3-和-5-的倍数&quot;&gt;&lt;a href=&quot;#关卡-1：3-和-5-的倍数&quot; class=&quot;headerlink&quot; title=&quot;关卡 1：3 和 5 的倍数&quot;&gt;&lt;/a&gt;关卡 1：3 和 5 的倍数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果我们列出 10
      
    
    </summary>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/categories/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="FCC欧拉计划" scheme="http://yoursite.com/tags/FCC%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题9</title>
    <link href="http://yoursite.com/2019/11/06/FCC%E7%AE%97%E6%B3%95%E9%A2%989/"/>
    <id>http://yoursite.com/2019/11/06/FCC%E7%AE%97%E6%B3%95%E9%A2%989/</id>
    <published>2019-11-06T02:35:07.000Z</published>
    <updated>2019-11-06T14:53:37.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><blockquote><p>另一种非常常见的排序方式是归并排序。如同快速排序一样，归并排序也是采用了分而治之的递归方法来排序数组。它利用了这么一个现象，即只要首先对两个数组进行排序，就比较容易对他们进行排序。但是我们的参数只能一个数组，那么又将如何从这个数组中得到两个排序数组呢？我们可以递归的将原始数组一分为二，直到数组里面只包含一个元素为止。单个元素的数组是自然排序的，所以我们可以开始合并。这种合并方式是将拆分的原始数组进行递归调用，最后将所有的元素生成一个最终的排序数组。<br><br>合并的步骤是：<br><br>1)：递归的将输入数组拆分成两个子数组，直到所有的子数组都只包含一个元素。<br><br>2)：将每一个排序后的子数组合并到一个数组里面，最后返回一个排序的数组。<br><br>归并排序是一种高效的排序方式，时间复杂度为 O(nlog(n))。因为归并排序的性能优良且相对容易实现，所有这种排序方式很受欢迎。<br><br>另外，这将是我们在此章节讨论的最后一种排序算法，但是在后续有关树型数据结构的章节中，我们将一起研究堆排序，同样它也是一种高效的排序方式，其实现过程需要用到二进制堆的概念。<br><br>Instructions：创建一个函数并命名为 mergeSort，输入参数是一个数组，且数组元素全部都是整数类型，然后按照从最小到最大的顺序返回整个数组&gt;。实现这个排序方式可以采用两个函数来实现：merge 负责合并两个排序的数组，merge sort 负责生成单个数组的用于归并使用。祝你好运！<br><br>注意：<br>我们将在后台调用这些函数，测试数组在编辑器中也是被注释掉了的。尝试记录输入 array 来确认你的冒泡排序算法是否正确。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于拆分数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> middlePos = ~~(array.length / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> left = array.slice(<span class="number">0</span>, middlePos)</span><br><span class="line"><span class="keyword">const</span> right = array.slice(middlePos)</span><br><span class="line"><span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line"><span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">res.push(left.shift())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.push(right.shift())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.concat(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>百度指出，如果使用递归方法，当数组长度超过一定值时浏览器可能会发生栈溢出错误，所以百度上还提到了非递归的写法，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePass</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">arr = [],</span></span></span><br><span class="line"><span class="function"><span class="params">temp = new Array(arr.length</span>),</span></span><br><span class="line"><span class="function"><span class="title">N</span> = <span class="title">arr</span>.<span class="title">length</span>,</span></span><br><span class="line"><span class="function"><span class="title">length</span> = 1</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line"><span class="comment">// 将每个元素看作是相邻的数组长度为1。</span></span><br><span class="line"><span class="keyword">let</span> t <span class="comment">// 迭代深度。</span></span><br><span class="line"><span class="keyword">for</span> (t = <span class="number">0</span>; <span class="built_in">Math</span>.pow(<span class="number">2</span>, t) &lt; N; t++, length *= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 每次跳过的长度翻倍。</span></span><br><span class="line"><span class="keyword">const</span> even = t % <span class="number">2</span> === <span class="number">0</span> <span class="comment">// 复用 arr 和 temp 来回赋值。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> left = <span class="number">0</span>; left &lt; N; left += <span class="number">2</span> * length) &#123;</span><br><span class="line"><span class="comment">// 左边数组起始位置 left 从0开始。</span></span><br><span class="line"><span class="keyword">const</span> middle = left + length &lt; N ? left + length : left <span class="comment">// 右边数组起始位置 middle 就是left + 一个数组长度length 但是不要超过 N 。</span></span><br><span class="line"><span class="keyword">const</span> right = left + <span class="number">2</span> * length &lt; N ? left + <span class="number">2</span> * length : N <span class="comment">// 右边界 right 就是 left + 两个数组长度。</span></span><br><span class="line">merge(even ? arr : temp, even ? temp : arr, left, middle, right) <span class="comment">// 合并每两个相邻的数组。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">merge(arr, temp, <span class="number">0</span>, <span class="built_in">Math</span>.pow(<span class="number">2</span>, t - <span class="number">1</span>), N) <span class="comment">// 上面的迭代深度始终少一次在这里补足。</span></span><br><span class="line">arr = temp <span class="comment">// 将稳定的数组赋值给 arr 释放掉 temp 。</span></span><br><span class="line"><span class="keyword">return</span> arr <span class="comment">// 返回 arr 。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, temp, left, middle, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> leftEnd = middle - <span class="number">1</span> <span class="comment">// 通过右边数组的起始位置得到左边数组的结束位置。</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= leftEnd &amp;&amp; middle &lt; right) &#123;</span><br><span class="line"><span class="comment">// 如果‘指针’没有越界。</span></span><br><span class="line"><span class="keyword">if</span> (arr[left] &gt; arr[middle]) &#123;</span><br><span class="line"><span class="comment">// 如果左边数组第一个元素比右边数组第一个元素大。</span></span><br><span class="line">temp[left + middle - leftEnd - <span class="number">1</span>] = arr[middle++] <span class="comment">// 将右边数组最小的放入有序数组 temp（初始值为空)。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[left + middle - leftEnd - <span class="number">1</span>] = arr[left++] <span class="comment">// 将左边数组最小的放入有序数组 temp（初始值为空)。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &gt; leftEnd &amp;&amp; middle &lt; right) &#123;</span><br><span class="line"><span class="comment">// 如果左边数组放完了，右边数组还有元素。</span></span><br><span class="line">temp[left + middle - leftEnd - <span class="number">1</span>] = arr[middle++] <span class="comment">// 那么依次将右边数组剩余的元素放入 temp 。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= leftEnd &amp;&amp; middle &gt;= right) &#123;</span><br><span class="line"><span class="comment">// 如果右边数组放完了，左边数组还有元素</span></span><br><span class="line">temp[left + middle - leftEnd - <span class="number">1</span>] = arr[left++] <span class="comment">// 那么依次将左边数组剩余的元素放入 temp 。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，FCC 面试攻略中的算法部分做完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合并排序&quot;&gt;&lt;a href=&quot;#合并排序&quot; class=&quot;headerlink&quot; title=&quot;合并排序&quot;&gt;&lt;/a&gt;合并排序&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;另一种非常常见的排序方式是归并排序。如同快速排序一样，归并排序也是采用了分而治之的递归方法来排序数
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题8</title>
    <link href="http://yoursite.com/2019/11/05/FCC%E7%AE%97%E6%B3%95%E9%A2%988/"/>
    <id>http://yoursite.com/2019/11/05/FCC%E7%AE%97%E6%B3%95%E9%A2%988/</id>
    <published>2019-11-05T00:20:02.000Z</published>
    <updated>2019-11-05T10:22:16.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>冒泡排序，将是你遇到的几个排序算法中的第一个。给定一个未排序的数组，我们期望能够返回的是一个有序的数组。我们将采用不同的几种方式来实现这个功能，并且了解到不同方式的优劣之处，找到最适合的方式来实现不同的应用环境。尽管大多数的现代编程语言在内部构建了这种排序方式并提供了相应的 API，但仍然很有必要了解一些基本的方法并且知道他们是如何完成实现的。<br><br>现在我们来了解一下冒泡排序。冒泡排序方法从未排序的数组开头开始，并且将未排序的数组元素往后挪移，然后迭代数组，直到所有的数组元素都完全排序后才停止。这种方式是，通过比较相邻的元素然后置换元素完成排序。这种方式就是便利循环数组，直到整个数组没有元素交换为止，这样就完成了冒泡排序。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。<br><br>这种方式通过多次迭代数组来完成操作，不管是平均还是最坏的情况，都是具有二次时间复杂度。尽管这个方式简单，但是在实际应用中，大多数情况下不切实际的：时间复杂度过高。<br><br>说明：创建一个函数并命名为 bubbleSort，输入参数是一个数组，且数组元素全部都是整数类型，然后按照从最小到最大的顺序返回整个数组。<br><br>注意：<br>我们将在后台调用这些函数，测试数组在编辑器中也是被注释掉了的。尝试记录输入 array 来确认你的冒泡排序算法是否正确。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line"><span class="comment">// 交换两个值，要求两个数值都是数字类型整数</span></span><br><span class="line">array[i] ^= array[j]</span><br><span class="line">array[j] ^= array[i]</span><br><span class="line">array[i] ^= array[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数组：</span></span><br><span class="line"><span class="comment">// [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]</span></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>现在我们开始实现选择排序。选择排序是通过选择列表中最小值来与列表中的第一个值进行对比交换，然后从第二位置开始逐一对比，选择剩下的列表中最小值与第二个元素交换位置。然后循环遍历列表并交换元素，直到列表最后一个元素，此时的列表就完成了排序。选择排序在所有的情况下都具有二次时间复杂度。<br><br>说明：创建一个函数并命名为 selectionSort，输入参数是一个数组，且数组元素全部都是整数类型，然后按照从最小到最大的顺序返回整个数组。<br><br>注意：<br>我们将在后台调用这些函数，测试数组在编辑器中也是被注释掉了的。尝试记录输入 array 来确认你的冒泡排序算法是否正确。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (array.length === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [first, ...otherArr] = array</span><br><span class="line"><span class="keyword">const</span> [minNum, minPos] = minNumAndPos(otherArr)</span><br><span class="line"><span class="keyword">if</span> (first &lt; minNum) &#123;</span><br><span class="line"><span class="keyword">return</span> [first].concat(selectionSort(otherArr))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">otherArr[minPos] = first</span><br><span class="line"><span class="keyword">return</span> [minNum].concat(selectionSort(otherArr))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minNumAndPos</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> minNum = <span class="built_in">Math</span>.min(...array)</span><br><span class="line"><span class="keyword">const</span> minPos = array.indexOf(minNum, array)</span><br><span class="line"><span class="keyword">return</span> [minNum, minPos]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>现在我们开始研究插入排序。这个方法通过在列表的开头见一个排序的数组来实现整个排序，它以第一个元素开始排序数组，然后检查对比下一个元素，并将其向后交换到排序的书中，直到它处在排序的位置。循环迭代整个列表，将新产生的元素交换到排序部分，直到整个列表处于排序状态。该算法在平均和最坏的情况下具有二次时间复杂度。<br><br>说明：创建一个函数并命名为 insertionSort，输入参数是一个数组，且数组元素全部都是整数类型，然后按照从最小到最大的顺序返回整个数组。<br><br>注意：<br>我们将在后台调用这些函数，测试数组在编辑器中也是被注释掉了的。尝试记录输入 array 来确认你的冒泡排序算法是否正确。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> resArr = [array[<span class="number">0</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i] &lt;= resArr[<span class="number">0</span>]) &#123;</span><br><span class="line">resArr.unshift(array[i])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &gt;= resArr[resArr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">resArr.push(array[i])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; resArr.length; j++) &#123;</span><br><span class="line"><span class="keyword">const</span> before = resArr[j]</span><br><span class="line"><span class="keyword">const</span> after = resArr[j + <span class="number">1</span>]</span><br><span class="line"><span class="comment">// 寻找数字在新数组中的位置</span></span><br><span class="line"><span class="keyword">if</span> (array[i] === after || (array[i] &gt; before &amp;&amp; array[i] &lt; after)) &#123;</span><br><span class="line">resArr = [...resArr.slice(<span class="number">0</span>, j + <span class="number">1</span>), array[i], ...resArr.slice(j + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>现在我们开始讨论快速排序。快速排序是一种高效的递归分治方法来排序数组。在这个方法中，需要在原始数组中选择一个枢轴值，然后将数组划分为两个子数组，其值大于或者小于枢轴值，然后我们将递归调用两个子数组上的快速排序算法的结果来配合使用，直到空数组或者单个元素的数组的情况，然后返回结果。递归调用的展开结果将返回的是排序后的数组。<br><br>快速排序是一种非常有效的排序方式，平均时间复杂度为 O(nlog(n))，同时它也是相对比较容易实现的方式。这些特性使得快速排序成为了一种流行而有用的排序方式。<br><br>说明：创建一个函数并命名为 quickSort，输入参数是一个数组，且数组元素全部都是整数类型，然后按照从最小到最大的顺序返回整个数组。虽然选择一个枢轴值很重要，但任何一个枢轴都能满足要求，为了以防万一，我嘛一般选择第一个或者最后一个元素来作为数轴值。<br><br>注意：<br>我们将在后台调用这些函数，测试数组在编辑器中也是被注释掉了的。尝试记录输入 array 来确认你的冒泡排序算法是否正确。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> middlePos = ~~(array.length / <span class="number">2</span>) <span class="comment">// 向下取整</span></span><br><span class="line"><span class="keyword">const</span> middleNum = array.splice(middlePos, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> left = []</span><br><span class="line"><span class="keyword">const</span> right = []</span><br><span class="line">array.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">val &lt; middleNum ? left.push(val) : right.push(val)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> [...quickSort(left), middleNum, ...quickSort(right)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;冒泡排序，将是你遇到的几个排序算法中的第一个。给定一个未排序的数组，我们期望能够返回的是一个有序的
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题7</title>
    <link href="http://yoursite.com/2019/11/04/FCC%E7%AE%97%E6%B3%95%E9%A2%987/"/>
    <id>http://yoursite.com/2019/11/04/FCC%E7%AE%97%E6%B3%95%E9%A2%987/</id>
    <published>2019-11-04T03:08:30.000Z</published>
    <updated>2019-11-04T09:14:43.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新库存"><a href="#更新库存" class="headerlink" title="更新库存"></a>更新库存</h3><blockquote><p>创建一个二维数组，比较并更新存储在二维数组中的“库存”元素，然后并将其与新产生的第二个二维数组进行对比，更新当前的 ”库存“ 项的数量（arr1），如果找不到这个对比对象，那么将新的对象和数量添加到“库存”数组中。注意：返回的“库存”数组应该是按照数组元素的首字母顺序排序</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateInventory</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> extraArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr1.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr1[j][<span class="number">1</span>] === arr2[i][<span class="number">1</span>]) &#123;</span><br><span class="line">arr1[j][<span class="number">0</span>] = arr1[j][<span class="number">0</span>] + arr2[i][<span class="number">0</span>]</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">extraArr.push(arr2[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = arr1</span><br><span class="line">.concat(extraArr)</span><br><span class="line">.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>].charCodeAt() - b[<span class="number">1</span>].charCodeAt())</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个货物列表示例</span></span><br><span class="line"><span class="keyword">const</span> curInv = [</span><br><span class="line">[<span class="number">21</span>, <span class="string">'Bowling Ball'</span>],</span><br><span class="line">[<span class="number">2</span>, <span class="string">'Dirty Sock'</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="string">'Hair Pin'</span>],</span><br><span class="line">[<span class="number">5</span>, <span class="string">'Microphone'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newInv = [</span><br><span class="line">[<span class="number">2</span>, <span class="string">'Hair Pin'</span>],</span><br><span class="line">[<span class="number">3</span>, <span class="string">'Half-Eaten Apple'</span>],</span><br><span class="line">[<span class="number">67</span>, <span class="string">'Bowling Ball'</span>],</span><br><span class="line">[<span class="number">7</span>, <span class="string">'Toothpaste'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = updateInventory(curInv, newInv)</span><br></pre></td></tr></table></figure><h3 id="请不要重复"><a href="#请不要重复" class="headerlink" title="请不要重复"></a>请不要重复</h3><blockquote><p>把一个字符串中的所有的字符重新排列，然后生成一个新的字符串，返回的新字符串中没有连续重复的字符。连续重复是以单个字符为判断标准。<br><br>例如：aab 应该返回 2， 因为它总共有 6 种排列方式： aab， aab， aba， aba， baa， baa，但是其中只有 2 个没有连续重复的字符（字符 a 是本例中的重复字符）：aba，aba</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permAlone</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> len = str.length</span><br><span class="line"><span class="keyword">let</span> newstr = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permute</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> result = []</span><br><span class="line"><span class="keyword">if</span> (str.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [str]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> temp = permute(str.slice(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; temp[i].length + <span class="number">1</span>; j++) &#123;</span><br><span class="line">newstr = temp[i].slice(<span class="number">0</span>, j) + str[<span class="number">0</span>] + temp[i].slice(j)</span><br><span class="line">result.push(newstr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> final = permute(str)</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/([A-Za-z])\1+/g</span></span><br><span class="line">final = final.filter(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !val.match(reg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> final.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">permAlone(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><h3 id="结对"><a href="#结对" class="headerlink" title="结对"></a>结对</h3><blockquote><p>给定一个数组 arr，查找其总和等于第二个参数“arg ”的元素对，并返回其索引的总和。<br><br>你可以使用多个具有相同数字元素但不同索引的对。每对应该使用尽可能低的可用索引。一旦一个元素被使用，它就不能被重用来与另一个元素配对。例如，pairwise([1, 1, 2], 3)使用索引为 0 的元素 1 而不是索引为 1 的元素 1 创建一对[ 2，1 ]，因为 0 + 2 &lt; 1 + 2。<br><br>例如：pairwise([7, 9, 11, 13, 15], 20)返回 6。满足和为 20 的一组数组是：[7, 13]和[9, 11]，然后我们可以写出对应的数组，以及他们的索引与他们的值。</p></blockquote><table><thead><tr><th>索引</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>值</td><td>7</td><td>9</td><td>11</td><td>13</td><td>15</td></tr></tbody></table><blockquote><p>然后我们将对应的索引相加，<br>7 + 13 = 20 →: 索引 0 + 3 = 3<br>9 + 11 = 20 →: 索引 1 + 2 = 3<br>3 + 3 = 6 → 应该返回 6。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairwise</span>(<span class="params">arr, arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> temp = arg - arr[i]</span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(temp) !== <span class="number">-1</span> &amp;&amp; arr.indexOf(temp) !== i) &#123;</span><br><span class="line">res = res + arr.indexOf(temp) + i</span><br><span class="line"><span class="comment">// 防止重复寻找同一组数据</span></span><br><span class="line">arr.splice(i, <span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line">arr.splice(arr.indexOf(temp), <span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pairwise([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>], <span class="number">7</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;更新库存&quot;&gt;&lt;a href=&quot;#更新库存&quot; class=&quot;headerlink&quot; title=&quot;更新库存&quot;&gt;&lt;/a&gt;更新库存&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;创建一个二维数组，比较并更新存储在二维数组中的“库存”元素，然后并将其与新产生的第二个二维数组进行
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题6</title>
    <link href="http://yoursite.com/2019/11/03/FCC%E7%AE%97%E6%B3%95%E9%A2%986/"/>
    <id>http://yoursite.com/2019/11/03/FCC%E7%AE%97%E6%B3%95%E9%A2%986/</id>
    <published>2019-11-03T01:05:09.000Z</published>
    <updated>2019-11-04T07:54:59.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造一个-Person-类"><a href="#构造一个-Person-类" class="headerlink" title="构造一个 Person 类"></a>构造一个 Person 类</h3><blockquote><p>在这道题目中，我们需要写一个构造器（constructor）函数。它只接收一个字符串参数 firstAndLast，这个参数代表一个英文名的全名（姓和名）。这个构造函数创建出的实例需要具有以下方法：<br><br>getFirstName() getLastName() getFullName() setFirstName(first) setLastName(last) setFullName(firstAndLast)<br><br>这些方法应当可以通过构造函数创建出的实例调用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">firstAndLast</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 请先写出这个方法。其他方法的写法与这个类似</span></span><br><span class="line"><span class="keyword">this</span>.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> firstAndLast</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.getLastName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstAndLast.split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.getFirstName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstAndLast.split(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.setFirstName = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">firstAndLast = val + <span class="string">' '</span> + firstAndLast.split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.setFullName = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">firstAndLast = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.setLastName = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">firstAndLast = firstAndLast.split(<span class="string">' '</span>)[<span class="number">0</span>] + <span class="string">' '</span> + val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> firstAndLast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bob = <span class="keyword">new</span> Person(<span class="string">'Bob Ross'</span>)</span><br><span class="line">bob.getFullName()</span><br></pre></td></tr></table></figure><h3 id="绘制碎片图"><a href="#绘制碎片图" class="headerlink" title="绘制碎片图"></a>绘制碎片图</h3><blockquote><p>在这道题目中，我们需要写一个计算天体轨道周期的函数，它接收一个对象数组参数 arr，对象中包含表示天体名称的 name 属性，及表示轨道半长轴的 avgAlt 属性。就像这样：<code>{name: &#39;name&#39;, avgAlt: avgAlt}</code>。<br><br>这个函数的返回值也是一个对象数组，应保留原对象中的 name 属性和值，然后根据 avgAlt 属性的值求出轨道周期（单位是秒），并赋值给 orbitalPeriod 属性。返回值中不应保留原数据中的 avgAlt 属性及其对应的值。<br><br>你可以在这条维基百科的链接中找到轨道周期的计算公式。<br><br>轨道周期的计算以地球为基准（即环绕地球的轨道周期），计算结果应取整到最接近的整数。<br><br>地球的半径是 6367.4447 千米，地球的 GM 值为 398600.4418 km3s-2。</p></blockquote><p>$T=\sqrt{\frac{4\pi(r+h)^3}{GM}}=2\pi\sqrt{\frac{a^3}{\mu}}$<br>其中$a$为轨道的半长轴，$\mu=GM$</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orbitalPeriod</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> GM = <span class="number">398600.4418</span></span><br><span class="line"><span class="keyword">const</span> earthRadius = <span class="number">6367.4447</span></span><br><span class="line"><span class="keyword">const</span> retArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.name = arr[i].name</span><br><span class="line">obj.orbitalPeriod = calOrbital(arr[i].avgAlt, GM, earthRadius)</span><br><span class="line">retArr.push(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calOrbital</span>(<span class="params">avgAlt, GM, earthRadius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.round(</span><br><span class="line"><span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(avgAlt + earthRadius, <span class="number">3</span>) / GM)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">orbitalPeriod([&#123; <span class="attr">name</span>: <span class="string">'sputnik'</span>, <span class="attr">avgAlt</span>: <span class="number">35873.5553</span> &#125;])</span><br></pre></td></tr></table></figure><h3 id="找到对等分差"><a href="#找到对等分差" class="headerlink" title="找到对等分差"></a>找到对等分差</h3><blockquote><p>知识提要：对称差 (Symmetric Difference)，数学上，两个集合的对称差分是只属于其中一个集合，而不属于另一个集合的元素组成的集合，例如：集合 let A = [ 1, 2, 3]和 let B = [ 2, 3, 4]的对称差分为 A △ B = C = [ 1, 4]。 集合论中的这个运算相当于布尔逻辑中的异或运算。<br><br>创建一个函数 sym，输入两个或两个以上的数组作为参数，然后返回值为对称差分的数组<br><br>思路：设定两个数组 (例如：let A = [1, 2, 3]，let B = [2, 3, 4])作为参数传入，返回对称差分数组（A △ B = C = [1, 4]），且数组中没有重复项。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sym</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">args.forEach(<span class="function">(<span class="params">val, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">array[index] = [...new <span class="built_in">Set</span>(val)]</span><br><span class="line">&#125;)</span><br><span class="line">args = [].concat(...args)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line">args.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (obj[val]) &#123;</span><br><span class="line">obj[val]++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">obj[val] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj[key] &amp;&amp; obj[key] % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(key))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sym([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;构造一个-Person-类&quot;&gt;&lt;a href=&quot;#构造一个-Person-类&quot; class=&quot;headerlink&quot; title=&quot;构造一个 Person 类&quot;&gt;&lt;/a&gt;构造一个 Person 类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在这道题目中，我们需要写一
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题5</title>
    <link href="http://yoursite.com/2019/11/02/FCC%E7%AE%97%E6%B3%95%E9%A2%985/"/>
    <id>http://yoursite.com/2019/11/02/FCC%E7%AE%97%E6%B3%95%E9%A2%985/</id>
    <published>2019-11-02T01:59:47.000Z</published>
    <updated>2019-11-02T03:21:34.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h3><blockquote><p>在这道题目中，我们需要写一个函数，它接收两个参数，分别为一个数组 arr 以及一个函数 func。我们需要从数组的第一个元素开始，用 func 来检查数组的每项。函数最终的返回值也是一个数组，它由原数组中第一个使得 func 为 true 的元素及其之后的所有元素组成。<br><br>如果数组中的所有元素都不能让 func 为 true，则返回空数组[]。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropElements</span>(<span class="params">arr, func</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 删掉那些该舍弃的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (func(arr[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> arr.slice(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dropElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &lt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><blockquote><p>在这道题目中，我们需要写一个数组扁平化的函数。<br><br>注意，你写的函数应该能够处理数组多级嵌套的情况。比如，[1, [2], [3, [4]]]在扁平化处理后的结果应为[1, 2, 3, 4]。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">steamrollArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 扁平化，扁平化……</span></span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line">ergodic(res, arr)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ergodic</span>(<span class="params">target, arr</span>) </span>&#123;</span><br><span class="line">arr.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">ergodic(target, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">target.push(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">steamrollArray([<span class="number">1</span>, [<span class="number">2</span>], [<span class="number">3</span>, [[<span class="number">4</span>]]]])</span><br></pre></td></tr></table></figure><h3 id="二进制转化"><a href="#二进制转化" class="headerlink" title="二进制转化"></a>二进制转化</h3><blockquote><p>在这道题目中，我们需要写一个把二进制输入转换成英文句子的函数。<br><br>传入函数的二进制字符串会用空格作为分隔符。</p></blockquote><p>parseInt()括号中有两个参数，第一个参数是数据，第二个参数是放入数据的进制。默认转成 10 进制输出。例如<code>parseInt(val, 2)</code>。此外，toString()可以将数字转换成字符串，括号中可以填写想要转换成的进制数，如把 num 转换成 2 进制，可以写成<code>num.toString(2)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryAgent</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> strArr = str.split(<span class="string">' '</span>)</span><br><span class="line">strArr = strArr.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(<span class="built_in">parseInt</span>(val, <span class="number">2</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(strArr)</span><br><span class="line"><span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">binaryAgent(</span><br><span class="line"><span class="string">'01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="真假值判断"><a href="#真假值判断" class="headerlink" title="真假值判断"></a>真假值判断</h3><blockquote><p>在这道题目中，我们需要写一个函数，它接收两个参数。第一个参数为对象数组 collection，第二个参数为一个字符串 pre，代表对象的一个键（key）。我们需要检查对象数组中每个对象的 pre 属性对应的值是否都为 “真”（truthy）。如果是，则返回 true，否则返回 false。<br><br>JavaScript 中，如果一个值在 Boolean 的上下文中（比如 if 语句）可以被执行为 true，那么这个值就被认为是 truthy 的。<br><br>注意，你可以选择使用.或[]来访问对象属性对应的值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truthCheck</span>(<span class="params">collection, pre</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; collection.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!collection[i][pre]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">truthCheck(</span><br><span class="line">[</span><br><span class="line">&#123; <span class="attr">user</span>: <span class="string">'Tinky-Winky'</span>, <span class="attr">sex</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">user</span>: <span class="string">'Dipsy'</span>, <span class="attr">sex</span>: <span class="string">'male'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">user</span>: <span class="string">'Laa-Laa'</span>, <span class="attr">sex</span>: <span class="string">'female'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">user</span>: <span class="string">'Po'</span>, <span class="attr">sex</span>: <span class="string">'female'</span> &#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">'sex'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><blockquote><p>在这道题目中，我们需要写一个求和的函数，但它接收的参数数量不定。如果传入了两个参数，那么直接返回两数之和即可。如果只传入一个参数，那我们应该返回另一个函数用来接收下一个参数，然后求出两数之和。<br><br>比如，addTogether(2, 3)应该返回 5。而 addTogether(2)应该返回一个函数。<br><br>然后我们调用这个返回的函数，并给它传入另一个用于求和的值：<br><br>var sumTwoAnd = addTogether(2);<br><br>sumTwoAnd(3)此时应返回 5。<br><br>只要其中任何一个参数不是数字，那我们就应返回 undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTogether</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> val = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; val.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val[i] !== <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val.length === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">otherval</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> otherval !== <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> otherval + val[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val[<span class="number">0</span>] + val[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addTogether(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;放弃&quot;&gt;&lt;a href=&quot;#放弃&quot; class=&quot;headerlink&quot; title=&quot;放弃&quot;&gt;&lt;/a&gt;放弃&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在这道题目中，我们需要写一个函数，它接收两个参数，分别为一个数组 arr 以及一个函数 func。我们需要从数组的
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题4</title>
    <link href="http://yoursite.com/2019/11/01/FCC%E7%AE%97%E6%B3%95%E9%A2%984/"/>
    <id>http://yoursite.com/2019/11/01/FCC%E7%AE%97%E6%B3%95%E9%A2%984/</id>
    <published>2019-10-31T23:49:16.000Z</published>
    <updated>2019-11-02T01:48:32.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="求斐波那契数组中的奇数之和"><a href="#求斐波那契数组中的奇数之和" class="headerlink" title="求斐波那契数组中的奇数之和"></a>求斐波那契数组中的奇数之和</h3><blockquote><p>在这道题目中，我们需要写一个函数，参数为一个正整数 num。它的作用是计算斐波那契数列中，小于或等于 num 的奇数之和。<br><br>斐波那契数列中，第一和第二个数字都是 1，后面的每个数字由之前两数相加得出。斐波那契数列的前六个数字分别为：1、1、2、3、5、8。<br><br>比如，sumFibs(10)应该返回 10。因为斐波那契数列中，比 10 小的数字只有 1、1、3、5。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFibs</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> before = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> next = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> res = before</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (next &lt;= num) &#123;</span><br><span class="line"><span class="keyword">if</span> (next % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">res += next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成下一位斐波那契数据</span></span><br><span class="line"><span class="keyword">const</span> temp = next</span><br><span class="line">next = next + before</span><br><span class="line">before = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFibs(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="对所有素数求和"><a href="#对所有素数求和" class="headerlink" title="对所有素数求和"></a>对所有素数求和</h3><blockquote><p>在这道题目中，我们需要写一个函数，它接收一个数字参数 num，返回值为不大于这个数字的所有质数之和。<br><br>质数是大于 1 且仅可以被 1 和自己整除的数。比如，2 就是一个质数，因为它只可以被 1 和 2（它本身）整除。<br><br>注意，传入函数的 num 不一定是质数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumPrimes</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> count = num</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 已经限制count的值大于2了，所以没有在isPrimeNum函数中判断2以下的情况</span></span><br><span class="line"><span class="keyword">if</span> (isPrimeNum(count)) &#123;</span><br><span class="line">res += count</span><br><span class="line">&#125;</span><br><span class="line">count--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrimeNum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.sqrt(num))</span><br><span class="line"><span class="keyword">if</span> (num === <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % count === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">count--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumPrimes(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><blockquote><p>在这道题目中，我们需要写一个函数，它接收一个包含两个数字的数组参数 arr，它的返回值为这两个数字范围内所有数字（包含这两个数字）的最小公倍数。<br><br>注意，较小数不一定总是出现在数组的第一个元素。<br><br>比如，传入[1, 3]，那么函数的返回结果应为 1、2、3 的最小公倍数，即为 6。</p></blockquote><p>这里用欧几里得定律获取最小公倍数，原理是<code>gcd(a, b) = gcd(a, a%b)(a&gt;b)</code>直到<code>a%b===0</code>。最大公约数可以用<code>a*b/最小公倍数</code>的方式获得</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">smallestCommons</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">arr = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="keyword">let</span> num = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = arr[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= arr[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">num *= i / gcd(i, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m % n === <span class="number">0</span>) <span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> gcd(n, m % n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smallestCommons([<span class="number">2</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;求斐波那契数组中的奇数之和&quot;&gt;&lt;a href=&quot;#求斐波那契数组中的奇数之和&quot; class=&quot;headerlink&quot; title=&quot;求斐波那契数组中的奇数之和&quot;&gt;&lt;/a&gt;求斐波那契数组中的奇数之和&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在这道题目中，我们需要写一
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题3</title>
    <link href="http://yoursite.com/2019/10/31/FCC%E7%AE%97%E6%B3%95%E9%A2%983/"/>
    <id>http://yoursite.com/2019/10/31/FCC%E7%AE%97%E6%B3%95%E9%A2%983/</id>
    <published>2019-10-31T08:26:20.000Z</published>
    <updated>2019-11-01T08:37:45.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><blockquote><p>在这道题目中，我们需要写一个字符串的搜索与替换函数，它的返回值为完成替换后的新字符串。<br> <br>这个函数接收的第一个参数为待替换的句子。第二个参数为句中需要被替换的单词。第三个参数为替换后的单词。<br><br> 注意：你需要保留被替换单词首字母的大小写格式。即如果传入的第二个参数为 “Book”，第三个参数为 “dog”，那么替换后的结果应为 “Dog”</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReplace</span>(<span class="params">str, before, after</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> tempStr = after</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/[A-Z][a-z]*/</span></span><br><span class="line"><span class="keyword">if</span> (reg.test(before)) &#123;</span><br><span class="line">tempStr = tempStr.substr(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + tempStr.substr(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tempStr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.replace(before, tempStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myReplace(<span class="string">'A quick brown fox jumped over the lazy dog'</span>, <span class="string">'jumped'</span>, <span class="string">'leaped'</span>)</span><br></pre></td></tr></table></figure><h3 id="DNA-配对"><a href="#DNA-配对" class="headerlink" title="DNA 配对"></a>DNA 配对</h3><blockquote><p>在这道题目中，我们需要写一个函数，为 DNA 中的碱基配对。这个函数只接收一个表示碱基的字符串为参数，最后返回完成配对的二维数组。<br><br>碱基对 由一对碱基组成。碱基有四种，分别为 A（腺嘌呤）、T（胸腺嘧啶）、G（鸟嘌呤）和 C（胞嘧啶）。配对原则是：A 与 T 配对，C 与 G 配对。我们需要根据这个原则对传入的所有碱基进行配对。<br><br>对于每个传入的碱基，我们应采用数组的形式展示配对结果。其中，传入的碱基需要作为数组的第一个元素出现。最终返回的数组中应当包含参数中每一个碱基的配对结果。<br><br>比如，传入的参数是 GCG，那么函数的返回值应为 [[“G”, “C”], [“C”,”G”],[“G”, “C”]]</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairElement</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> res = []</span><br><span class="line">str.split(<span class="string">''</span>).map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">res.push([<span class="string">'A'</span>, <span class="string">'T'</span>])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">res.push([<span class="string">'T'</span>, <span class="string">'A'</span>])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>:</span><br><span class="line">res.push([<span class="string">'G'</span>, <span class="string">'C'</span>])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">res.push([<span class="string">'C'</span>, <span class="string">'G'</span>])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pairElement(<span class="string">'GCG'</span>)</span><br></pre></td></tr></table></figure><h3 id="丢失的字母"><a href="#丢失的字母" class="headerlink" title="丢失的字母"></a>丢失的字母</h3><blockquote><p>在这道题目中，我们需要写一个函数，找到传入的字符串里缺失的字母并返回它。<br><br> 判断缺失的依据是字母顺序，比如 abcdfg 中缺失了 e。而 abcdef 中就没有字母缺失，此时我们需要返回 undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fearNotLetter</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> start = strArr[<span class="number">0</span>].charCodeAt()</span><br><span class="line"><span class="keyword">const</span> end = strArr[strArr.length - <span class="number">1</span>].charCodeAt()</span><br><span class="line"><span class="keyword">if</span> (end - start + <span class="number">1</span> !== strArr.length) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strArr.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> pos = strArr[i].charCodeAt()</span><br><span class="line"><span class="keyword">if</span> (pos !== start + i) &#123;</span><br><span class="line"><span class="comment">// 说明缺失字母</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(start + i))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(start + i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fearNotLetter(<span class="string">'abce'</span>)</span><br></pre></td></tr></table></figure><h3 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h3><blockquote><p>在这道题目中，我们需要写一个函数，它接收两个或多个数组为参数。我们需要对这些数组中所有元素进行去除重复元素的处理，并以数组的形式返回去重结果。<br><br>需要注意的是，结果数组中的元素顺序必须与其传入的顺序保持一致。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniteUnique</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = [].concat(...arguments)</span><br><span class="line"><span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uniteUnique([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="转换-HTML-实体"><a href="#转换-HTML-实体" class="headerlink" title="转换 HTML 实体"></a>转换 HTML 实体</h3><blockquote><p>在这道题目中，我们需要写一个转换 HTML entity 的函数。需要转换的 HTML entity 有&amp;、&lt;、&gt;、”（双引号）和’（单引号）。转换的规则你可以在<a href="https://dev.w3.org/html5/html-author/charref" target="_blank" rel="noopener">W3C 官网</a>找到。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,</span><br><span class="line"><span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,</span><br><span class="line"><span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span>,</span><br><span class="line"><span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>,</span><br><span class="line"><span class="string">"'"</span>: <span class="string">'&amp;apos;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> strArr = [...str]</span><br><span class="line">strArr.forEach(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(val)) &#123;</span><br><span class="line">arr[index] = obj[val]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convertHTML(<span class="string">'Dolce &amp; Gabbana'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;搜索和替换&quot;&gt;&lt;a href=&quot;#搜索和替换&quot; class=&quot;headerlink&quot; title=&quot;搜索和替换&quot;&gt;&lt;/a&gt;搜索和替换&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在这道题目中，我们需要写一个字符串的搜索与替换函数，它的返回值为完成替换后的新字符串。&lt;b
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>FCC算法题2</title>
    <link href="http://yoursite.com/2019/10/30/FCC%E7%AE%97%E6%B3%95%E9%A2%982/"/>
    <id>http://yoursite.com/2019/10/30/FCC%E7%AE%97%E6%B3%95%E9%A2%982/</id>
    <published>2019-10-30T00:23:27.000Z</published>
    <updated>2019-10-31T23:49:44.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="罗密欧与朱丽叶"><a href="#罗密欧与朱丽叶" class="headerlink" title="罗密欧与朱丽叶"></a>罗密欧与朱丽叶</h3><blockquote><p>在这道题目中，我们要写一个函数，它接收两个参数：第一个参数是对象数组，第二个参数是一个对象。我们需要从对象数组中找出与第二个参数相等或包含第二个参数的所有对象，并以对象数组的形式返回。其中，相等的意思是原数组中的对象与第二个参数中对象的所有键值对完全相等；包含的意思是只要第二个参数中对象的所有键存在于原数组对象中，且它们对应的值相同即可。<br><br>比如，如果第一个参数是[{ first: “Romeo”, last: “Montague” }, { first: “Mercutio”, last: null }, { first: “Tybalt”, last: “Capulet” }]，第二个参数是{ last: “Capulet” }。那么你需要以对象数组的形式返回第一个参数中的第三个元素，因为它包含第二个参数中定义的键 last，且对应的值”Capulet”相同</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatIsInAName</span>(<span class="params">collection, source</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> srcKeys = <span class="built_in">Object</span>.keys(source)</span><br><span class="line"><span class="keyword">const</span> resArr = collection.filter(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">srcKeys.map(<span class="function"><span class="params">srcValue</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 如果source提供的key不存在，或者source中key对应的value与collection中的不一致</span></span><br><span class="line"><span class="keyword">if</span> (!val.hasOwnProperty(srcValue) || val[srcValue] !== source[srcValue]) &#123;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> resArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatIsInAName(</span><br><span class="line">[</span><br><span class="line">&#123; <span class="attr">first</span>: <span class="string">'Romeo'</span>, <span class="attr">last</span>: <span class="string">'Montague'</span> &#125;,</span><br><span class="line">&#123; <span class="attr">first</span>: <span class="string">'Mercutio'</span>, <span class="attr">last</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">&#123; <span class="attr">first</span>: <span class="string">'Tybalt'</span>, <span class="attr">last</span>: <span class="string">'Capulet'</span> &#125;</span><br><span class="line">],</span><br><span class="line">&#123; <span class="attr">last</span>: <span class="string">'Capulet'</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="短线连接格式"><a href="#短线连接格式" class="headerlink" title="短线连接格式"></a>短线连接格式</h3><blockquote><p>在这道题目中，我们需要写一个函数，把一个字符串转换为“短线连接格式”。短线连接格式的意思是，所有字母都是小写，且用-连接。比如，对于 Hello World，应该转换为 hello-world；对于 I love_Javascript-VeryMuch，应该转换为 i-love-javascript-very-much。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spinalCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ?= 搜索后面的字符但不放到结果中保存</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/([A-Z]?[a-z]*)(?=[\W_])?/g</span></span><br><span class="line"><span class="comment">// 匹配后单词和单词之间存在空字符，可能是正则表达式写的不好，用filter过滤一下无效单词</span></span><br><span class="line"><span class="keyword">const</span> arr = str.match(reg).filter(<span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span> arr.join(<span class="string">'-'</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spinalCase(<span class="string">'This Is Spinal Tap'</span>)</span><br></pre></td></tr></table></figure><h3 id="儿童黑话"><a href="#儿童黑话" class="headerlink" title="儿童黑话"></a>儿童黑话</h3><blockquote><p>在这道题目中，我们需要写一个函数，把传入的字符串翻译成“儿童黑话”。<br><br>儿童黑话的基本转换规则很简单，只需要把一个英文单词的第一个辅音字母或第一组辅音从移到单词的结尾，并在后面加上 ay 即可。在英语中，字母 a、e、i、o、u 为元音，其余的字母均为辅音。辅音从的意思是连续的多个辅音字母。额外地，如果单词本身是以元音开头的，那只需要在结尾加上 way。<br><br>在本题中，传入的单词一定会是英文单词，且所有字母均为小写。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translatePigLatin</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> vowel = [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>]</span><br><span class="line"><span class="keyword">let</span> len = <span class="number">0</span> <span class="comment">// 辅音的长度</span></span><br><span class="line"><span class="comment">// 设置长度限制是为了防止全是辅音</span></span><br><span class="line"><span class="keyword">while</span> (vowel.indexOf(strArr[len]) === <span class="number">-1</span> &amp;&amp; len &lt;= strArr.length) &#123;</span><br><span class="line">len++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 第一个字母为元音</span></span><br><span class="line"><span class="keyword">return</span> str + <span class="string">'way'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str.substr(len) + str.substr(<span class="number">0</span>, len) + <span class="string">'ay'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">translatePigLatin(<span class="string">'consonant'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;罗密欧与朱丽叶&quot;&gt;&lt;a href=&quot;#罗密欧与朱丽叶&quot; class=&quot;headerlink&quot; title=&quot;罗密欧与朱丽叶&quot;&gt;&lt;/a&gt;罗密欧与朱丽叶&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在这道题目中，我们要写一个函数，它接收两个参数：第一个参数是对象数组，第二
      
    
    </summary>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/categories/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="FCC算法题" scheme="http://yoursite.com/tags/FCC%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
